<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Primary Meta Tags -->
    <title>Photo Editor - Passport Photo Maker</title>
    <meta name="title" content="Photo Editor - Passport Photo Maker">
    <meta name="description" content="Edit and prepare your passport photo with professional tools. Adjust, crop, validate face position with AI. Create perfect passport photos.">
    <meta name="keywords" content="passport photo editor, photo crop tool, face validation, passport photo preparation, photo adjustment, photo editor online">
    <meta name="author" content="Photo Sheet Maker">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://aniltv06.github.io/passportphotosheet/photo-editor.html">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://aniltv06.github.io/passportphotosheet/photo-editor.html">
    <meta property="og:title" content="Photo Editor - Passport Photo Maker">
    <meta property="og:description" content="Professional passport photo editor with AI face validation. Adjust, crop, and prepare perfect passport photos.">
    <meta property="og:image" content="https://aniltv06.github.io/passportphotosheet/og-image.jpg">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://aniltv06.github.io/passportphotosheet/photo-editor.html">
    <meta name="twitter:title" content="Photo Editor - Passport Photo Maker">
    <meta name="twitter:description" content="Professional passport photo editor with AI face validation.">

    <!-- Theme and Mobile -->
    <meta name="theme-color" content="#007AFF">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Photo Editor">

    <!-- Favicons -->
    <link rel="icon" type="image/x-icon" href="favicon/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png">

    <!-- Dynamic Cache Control - Automatically manages cache based on environment -->
    <!-- Development: Disables cache for easier testing -->
    <!-- Production: Enables cache for better performance -->
    <script type="module" src="js/meta-loader.js"></script>

    <!-- MediaPipe Libraries for Face Detection -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation@0.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection@0.4"></script>

    <!-- Google Analytics 4 -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BHSENQTDSF"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-BHSENQTDSF', {
            'anonymize_ip': true,
            'cookie_flags': 'SameSite=None;Secure',
            'page_path': '/photo-editor.html'
        });

        // Track page view
        gtag('event', 'page_view', {
            page_title: 'Photo Editor',
            page_location: window.location.href,
            page_path: '/photo-editor.html'
        });
    </script>

    <!-- Microsoft Clarity -->
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "u9f5jiwh0y");
    </script>

    <!-- Structured Data for SEO -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Photo Editor - Passport Photo Maker",
      "applicationCategory": "UtilitiesApplication",
      "operatingSystem": "Any",
      "description": "Professional passport photo editor with AI face validation. Adjust, crop, and prepare perfect passport photos with guidelines.",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "featureList": [
        "Upload and crop passport photos",
        "AI-powered face validation",
        "Zoom and rotation controls",
        "US passport guideline overlay",
        "Grid with scale measurements",
        "High-quality 300 DPI output",
        "Privacy-focused (no server upload)",
        "Free forever"
      ],
      "browserRequirements": "Requires JavaScript. Requires HTML5.",
      "author": {
        "@type": "Organization",
        "name": "Photo Sheet Maker"
      }
    }
    </script>

    <style>
        :root {
            --primary-color: #007AFF;
            --primary-hover: #0051D5;
            --secondary-color: #5856D6;
            --accent-color: #FF2D55;
            --success-color: #34C759;
            --warning-color: #FF9500;
            --danger-color: #FF3B30;
            --text-primary: #1D1D1F;
            --text-secondary: #86868B;
            --background: #FFFFFF;
            --surface: #FFFFFF;
            --surface-secondary: #F5F5F7;
            --border: #D2D2D7;
            --shadow: rgba(0, 0, 0, 0.08);
            --shadow-md: rgba(0, 0, 0, 0.12);
            --shadow-lg: rgba(0, 0, 0, 0.16);
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 20px;
            --radius-xl: 24px;
            --spacing-xs: 8px;
            --spacing-sm: 12px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            --spacing-2xl: 48px;
            --spacing-3xl: 64px;
            --spacing-4xl: 96px;
            --font-system: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-smooth: all 0.6s cubic-bezier(0.16, 1, 0.3, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-system);
            background: var(--surface-secondary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Accessibility - Skip Link */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: var(--primary-color);
            color: white;
            padding: 8px 16px;
            text-decoration: none;
            border-radius: 0 0 4px 0;
            z-index: 100;
            font-weight: 600;
            transition: top 0.2s ease;
        }

        .skip-link:focus {
            top: 0;
            outline: 3px solid var(--warning-color);
            outline-offset: 2px;
        }

        /* Accessibility - Visually Hidden */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        /* Accessibility - Focus Indicators */
        *:focus-visible {
            outline: 3px solid var(--primary-color);
            outline-offset: 2px;
            border-radius: 4px;
        }

        button:focus-visible,
        a:focus-visible,
        input:focus-visible,
        select:focus-visible {
            outline: 3px solid var(--primary-color);
            outline-offset: 2px;
        }

        /* Accessibility - Reduced Motion */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
        }

        /* Accessibility - High Contrast Mode */
        @media (prefers-contrast: high) {
            :root {
                --primary-color: #0051D5;
                --text-primary: #000000;
                --text-secondary: #333333;
                --border: #000000;
            }

            .panel {
                border: 2px solid var(--border);
            }

            .btn {
                border: 2px solid currentColor;
            }
        }

        /* Hero Section - Apple Style (from index.html) */
        .hero {
            position: relative;
            min-height: 60vh;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: var(--spacing-4xl) var(--spacing-lg);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }

        .hero::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.1) 0%, transparent 50%);
            animation: pulse 10s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .hero-content {
            position: relative;
            z-index: 1;
            max-width: 900px;
            margin: 0 auto;
        }

        .hero-icon {
            width: 120px;
            height: 120px;
            margin: 0 auto var(--spacing-xl);
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: float 3s ease-in-out infinite;
        }

        .hero-icon svg {
            width: 60px;
            height: 60px;
        }

        /* Hero Camera Icon */
        .hero-camera-icon {
            width: 60px;
            height: 60px;
            position: relative;
        }
        .hero-camera-body {
            width: 100%;
            height: 70%;
            background: white;
            border-radius: 8px;
            position: absolute;
            bottom: 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        .hero-lens {
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #e0e0e0 0%, #f5f5f5 100%);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow:
                inset 0 1px 3px rgba(0, 0, 0, 0.1),
                0 2px 4px rgba(0, 0, 0, 0.15);
        }
        .hero-lens-inner {
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        .hero-lens-glare {
            width: 6px;
            height: 6px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            position: absolute;
            top: 25%;
            left: 25%;
        }
        .hero-flash {
            width: 10px;
            height: 10px;
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            border-radius: 50%;
            position: absolute;
            top: 15%;
            right: 15%;
            box-shadow: 0 2px 6px rgba(255, 165, 0, 0.4);
        }
        .hero-viewfinder {
            width: 8px;
            height: 6px;
            background: #333;
            border-radius: 2px;
            position: absolute;
            top: 12%;
            left: 15%;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .hero-title {
            font-size: clamp(48px, 8vw, 72px);
            font-weight: 700;
            color: white;
            margin-bottom: var(--spacing-lg);
            letter-spacing: -2px;
            line-height: 1.1;
        }

        .hero-subtitle {
            font-size: clamp(18px, 3vw, 24px);
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: var(--spacing-2xl);
            font-weight: 400;
            line-height: 1.5;
        }

        .hero-cta {
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: 18px 36px;
            background: white;
            color: var(--primary-color);
            border-radius: 980px;
            font-size: 18px;
            font-weight: 600;
            text-decoration: none;
            transition: var(--transition-smooth);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        .hero-cta:hover {
            transform: translateY(-2px);
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
        }

        .scroll-indicator {
            position: absolute;
            bottom: var(--spacing-2xl);
            left: 50%;
            transform: translateX(-50%);
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(10px); }
        }

        .scroll-indicator svg {
            width: 24px;
            height: 24px;
            color: white;
            opacity: 0.7;
        }

        /* Language Selector */
        .language-selector {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 10px 14px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.5);
            transition: var(--transition);
        }

        .language-selector:hover {
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }

        .language-selector select {
            border: none;
            background: transparent;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
            padding: 4px 24px 4px 8px;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1.5L6 6.5L11 1.5' stroke='%231D1D1F' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
        }

        .language-selector select:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
            border-radius: 4px;
        }

        /* Floating Home Button */
        .floating-home-btn {
            position: fixed;
            top: 30px;
            left: 30px;
            z-index: 1000;
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 50%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.5);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            animation: floatButton 3s ease-in-out infinite;
        }

        .floating-home-btn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 12px 40px rgba(102, 126, 234, 0.3);
            background: rgba(255, 255, 255, 1);
        }

        .floating-home-btn:active {
            transform: translateY(-2px) scale(1.02);
        }

        @keyframes floatButton {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* Camera icon for floating button */
        .floating-camera-icon {
            width: 35px;
            height: 35px;
            position: relative;
        }

        .floating-camera-body {
            width: 100%;
            height: 70%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 4px;
            position: absolute;
            bottom: 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .floating-lens {
            width: 16px;
            height: 16px;
            background: linear-gradient(135deg, #e0e0e0 0%, #f5f5f5 100%);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.15);
        }

        .floating-lens-inner {
            width: 12px;
            height: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.2);
        }

        .floating-lens-glare {
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            position: absolute;
            top: 25%;
            left: 25%;
        }

        .floating-flash {
            width: 6px;
            height: 6px;
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            border-radius: 50%;
            position: absolute;
            top: 10%;
            right: 12%;
            box-shadow: 0 1px 4px rgba(255, 165, 0, 0.4);
        }

        .floating-viewfinder {
            width: 5px;
            height: 4px;
            background: #333;
            border-radius: 1px;
            position: absolute;
            top: 8%;
            left: 12%;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .floating-home-btn {
                top: 20px;
                left: 20px;
                width: 60px;
                height: 60px;
            }

            .floating-camera-icon {
                width: 30px;
                height: 30px;
            }
        }

        /* Main Content Section */
        .main-content {
            background: var(--background);
            padding: var(--spacing-4xl) 0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: var(--spacing-xl) var(--spacing-lg);
        }

        /* Editor Layout */
        .editor-layout {
            display: grid;
            grid-template-columns: 320px 1fr 300px;
            gap: var(--spacing-lg);
            align-items: start;
            animation: fadeIn 0.6s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Panel/Card Styles - Matching index.html */
        .panel {
            background: var(--surface);
            border-radius: var(--radius-md);
            padding: var(--spacing-lg);
            box-shadow: 0 2px 16px var(--shadow), 0 0 0 1px rgba(0, 0, 0, 0.04);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(0, 0, 0, 0.04);
            position: relative;
            overflow: hidden;
        }

        .panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .panel:hover {
            box-shadow: 0 8px 32px var(--shadow-md), 0 0 0 1px rgba(0, 0, 0, 0.06);
            transform: translateY(-2px);
        }

        .panel:hover::before {
            opacity: 1;
        }

        .panel h3 {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: var(--spacing-md);
            color: var(--text-primary);
            letter-spacing: -0.3px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel h3::before {
            content: '';
            width: 4px;
            height: 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 2px;
        }

        /* Canvas Area */
        .canvas-panel {
            background: linear-gradient(135deg, #E5E5EA 0%, #D1D1D6 100%);
            padding: var(--spacing-xl);
            min-height: 600px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .canvas-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 10px,
                    rgba(255, 255, 255, 0.03) 10px,
                    rgba(255, 255, 255, 0.03) 20px
                );
            pointer-events: none;
        }

        .canvas-container {
            position: relative;
            background: #FFFFFF;
            box-shadow:
                0 10px 40px rgba(0,0,0,0.15),
                0 0 0 1px rgba(0,0,0,0.05),
                0 0 80px rgba(102, 126, 234, 0.1);
            border-radius: 12px;
            overflow: hidden;
            cursor: move;
            user-select: none;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1;
            /* Force proper compositing in Chrome */
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
            will-change: transform;
        }

        .canvas-container:hover {
            box-shadow:
                0 15px 50px rgba(0,0,0,0.2),
                0 0 0 1px rgba(0,0,0,0.08),
                0 0 100px rgba(102, 126, 234, 0.15);
        }

        #editCanvas {
            display: block;
            max-width: 100%;
            height: auto;
            /* Chrome-specific rendering improvements */
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        .overlay-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            max-width: 100%;
            height: auto;
            display: block;
            /* Ensure overlay doesn't affect underlying image brightness */
            mix-blend-mode: normal;
            isolation: isolate;
        }

        /* Guidelines Overlay */
        .guidelines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* Upload Area */
        .upload-area {
            border: 2px dashed var(--border);
            border-radius: var(--radius-md);
            padding: var(--spacing-xl);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(135deg, #FAFAFA 0%, #F5F5F7 100%);
            position: relative;
            overflow: hidden;
        }

        .upload-area::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300%;
            height: 300%;
            background: radial-gradient(circle, rgba(102, 126, 234, 0.03) 0%, transparent 70%);
            transform: translate(-50%, -50%) scale(0);
            transition: transform 0.6s ease;
        }

        .upload-area:hover::before {
            transform: translate(-50%, -50%) scale(1);
        }

        .upload-area:hover {
            border-color: var(--primary-color);
            background: linear-gradient(135deg, #FFFFFF 0%, #FAFAFA 100%);
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.1);
            transform: translateY(-2px);
        }

        .upload-area.dragover {
            border-color: var(--primary-color);
            background: rgba(102, 126, 234, 0.05);
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 12px;
            display: inline-block;
            animation: bounce 2s ease-in-out infinite;
            filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.1));
        }

        @keyframes bounceExcited {
            0%, 100% {
                transform: translateY(0) scale(1);
            }
            50% {
                transform: translateY(-15px) scale(1.1);
            }
        }

        .upload-area:hover .upload-icon {
            animation: bounceExcited 0.6s ease-in-out infinite;
        }

        .upload-text {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
            position: relative;
            z-index: 1;
        }

        .upload-hint {
            font-size: 14px;
            color: var(--text-secondary);
            position: relative;
            z-index: 1;
        }

        #fileInput {
            display: none;
        }

        /* Controls */
        .control-group {
            margin-bottom: var(--spacing-lg);
        }

        .control-label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(90deg, #E5E5EA 0%, #D1D1D6 100%);
            outline: none;
            transition: all 0.2s ease;
        }

        .slider:hover {
            background: linear-gradient(90deg, #D1D1D6 0%, #C7C7CC 100%);
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary-color) 0%, #0051D5 100%);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(0, 122, 255, 0.3);
            border: 2px solid white;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.5);
        }

        .slider::-webkit-slider-thumb:active {
            transform: scale(1.1);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary-color) 0%, #0051D5 100%);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 8px rgba(0, 122, 255, 0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .slider::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.5);
        }

        .slider-value {
            min-width: 45px;
            text-align: right;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .btn {
            width: 100%;
            padding: 14px 20px;
            border: none;
            border-radius: var(--radius-md);
            font-size: 15px;
            font-weight: 600;
            font-family: var(--font-system);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            margin-bottom: 12px;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:active::before {
            width: 300px;
            height: 300px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary-color) 0%, #0051D5 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3);
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #0051D5 0%, #003DA5 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 122, 255, 0.4);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(135deg, var(--surface) 0%, #F5F5F7 100%);
            color: var(--text-primary);
            border: 2px solid var(--border);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .btn-secondary:hover {
            border-color: var(--primary-color);
            background: linear-gradient(135deg, #FFFFFF 0%, #FAFAFA 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.15);
        }

        .btn-secondary:active {
            transform: translateY(0);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success-color) 0%, #28a745 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(52, 199, 89, 0.3);
        }

        .btn-success:hover {
            background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(52, 199, 89, 0.4);
        }

        .btn-success:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        /* Guidelines Toggle */
        .toggle-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .toggle-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: linear-gradient(135deg, #F9F9F9 0%, #F5F5F7 100%);
            border-radius: 10px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .toggle-item:hover {
            background: linear-gradient(135deg, #FFFFFF 0%, #F9F9F9 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            transform: translateX(2px);
        }

        .toggle-label {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
        }

        .toggle-switch {
            position: relative;
            width: 48px;
            height: 28px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            border-radius: 28px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            border-radius: 50%;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        input:checked + .toggle-slider {
            background: linear-gradient(135deg, var(--primary-color) 0%, #0051D5 100%);
            box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.1), inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(20px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        input:focus + .toggle-slider {
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.2);
        }

        /* Instructions */
        .instructions {
            background: linear-gradient(135deg, #E3F2FD 0%, #BBDEFB 100%);
            padding: var(--spacing-md);
            border-radius: 10px;
            font-size: 13px;
            line-height: 1.6;
            color: #0066CC;
            border: 1px solid rgba(0, 122, 255, 0.2);
            box-shadow: 0 2px 8px rgba(0, 122, 255, 0.1);
        }

        .instructions strong {
            display: block;
            margin-bottom: 8px;
            color: var(--primary-color);
            font-size: 14px;
        }

        .instructions ul {
            margin-left: 18px;
            margin-top: 8px;
        }

        .instructions li {
            margin-bottom: 4px;
            position: relative;
            padding-left: 4px;
        }

        .instructions li::marker {
            color: var(--primary-color);
        }

        /* Collapsible Instructions */
        .instructions-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
            margin-bottom: 8px;
            padding: 4px 0;
            transition: var(--transition);
        }

        .instructions-header:hover {
            opacity: 0.8;
        }

        .instructions-header strong {
            margin-bottom: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .collapse-icon {
            font-size: 18px;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: var(--primary-color);
            font-weight: bold;
        }

        .instructions.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .instructions-content {
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
            opacity: 1;
        }

        .instructions.collapsed .instructions-content {
            max-height: 0;
            opacity: 0;
        }

        /* Info Badge */
        .info-badge {
            background: linear-gradient(135deg, #FFF9E6 0%, #FFF3CD 100%);
            border: 1px solid #FFE69C;
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            font-size: 13px;
            color: #856404;
            margin-bottom: var(--spacing-md);
            box-shadow: 0 2px 12px rgba(255, 183, 77, 0.15);
            position: relative;
            overflow: hidden;
        }

        .info-badge::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, #FFA500, #FF9500);
        }

        .info-badge strong {
            display: block;
            margin-bottom: 6px;
            font-size: 14px;
            color: #664d03;
            padding-left: 12px;
        }

        .info-badge:last-child {
            margin-bottom: 0;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .editor-layout {
                grid-template-columns: 1fr;
                gap: var(--spacing-lg);
            }

            .left-panel, .right-panel {
                max-width: 600px;
                margin: 0 auto;
            }
        }

        @media (max-width: 768px) {
            .hero {
                min-height: 50vh;
                padding: var(--spacing-3xl) var(--spacing-md);
            }

            .hero-icon {
                width: 90px;
                height: 90px;
            }

            .hero-icon svg {
                width: 45px;
                height: 45px;
            }

            .hero-title {
                font-size: 36px;
            }

            .hero-subtitle {
                font-size: 18px;
            }

            .hero-cta {
                padding: 16px 28px;
                font-size: 16px;
            }

            .container {
                padding: var(--spacing-lg) var(--spacing-md);
            }

            .panel {
                padding: var(--spacing-md);
            }

            .panel h3 {
                font-size: 18px;
            }

            .editor-layout {
                gap: var(--spacing-md);
            }

            .language-selector {
                top: 10px;
                right: 10px;
            }
        }

        @media (max-width: 480px) {
            .hero-title {
                font-size: 28px;
            }

            .hero-cta {
                font-size: 14px;
                padding: var(--spacing-xs) var(--spacing-sm);
            }
        }

        /* Loading State */
        .loading {
            text-align: center;
            padding: var(--spacing-xl);
        }

        .spinner {
            border: 4px solid rgba(0, 122, 255, 0.1);
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s cubic-bezier(0.5, 0, 0.5, 1) infinite;
            margin: 0 auto 16px;
            position: relative;
        }

        .spinner::after {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            border-radius: 50%;
            border: 4px solid transparent;
            border-top-color: rgba(0, 122, 255, 0.3);
            animation: spin 2s cubic-bezier(0.5, 0, 0.5, 1) infinite reverse;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .processing-text {
            color: var(--text-secondary);
            font-size: 14px;
        }

        /* Footer Styles */
        .footer {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: var(--radius-xl);
            padding: var(--spacing-2xl);
            margin-top: var(--spacing-xl);
            box-shadow: 0 8px 32px var(--shadow-lg);
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        /* Footer styles moved to css/common.css */

        /* Validation Results Enhancements */
        #validationResults {
            animation: slideIn 0.4s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Photo Info Badge Enhancement */
        #photoInfo {
            animation: fadeIn 0.5s ease-out 0.3s both;
        }

        /* Add subtle glow effect to active canvas */
        .canvas-container:active {
            box-shadow:
                0 15px 50px rgba(0,0,0,0.25),
                0 0 0 1px rgba(0,0,0,0.1),
                0 0 120px rgba(102, 126, 234, 0.2);
        }

        /* Progress Steps */
        .progress-steps-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-xl);
            box-shadow: 0 4px 16px var(--shadow);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .progress-steps {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 600px;
            margin: 0 auto;
        }

        .progress-step {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            flex: 1;
            position: relative;
        }

        .progress-step-number {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: var(--surface-secondary);
            border: 3px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 18px;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            z-index: 2;
        }

        .progress-step.active .progress-step-number {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border-color: var(--primary-color);
            color: white;
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3);
            transform: scale(1.1);
        }

        .progress-step.completed .progress-step-number {
            background: var(--success-color);
            border-color: var(--success-color);
            color: white;
        }

        .progress-step.completed .progress-step-number::before {
            content: '‚úì';
        }

        .progress-step-label {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            text-align: center;
        }

        .progress-step.active .progress-step-label {
            color: var(--primary-color);
        }

        .progress-step.completed .progress-step-label {
            color: var(--success-color);
        }

        .progress-connector {
            height: 3px;
            background: var(--border);
            position: absolute;
            top: 24px;
            left: 50%;
            right: -50%;
            z-index: 1;
            transition: background 0.3s ease;
        }

        .progress-step:last-child .progress-connector {
            display: none;
        }

        .progress-step.completed .progress-connector {
            background: var(--success-color);
        }

        /* Touch Gesture Hints */
        .touch-hints {
            display: none;
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 12px 20px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 500;
            z-index: 100;
            animation: fadeInUp 0.5s ease-out;
            pointer-events: none;
            text-align: center;
            line-height: 1.4;
        }

        @media (hover: none) and (pointer: coarse) {
            .touch-hints {
                display: block;
            }
        }

        .touch-hint-icon {
            font-size: 20px;
            margin-bottom: 4px;
        }

        /* Mobile Improvements */
        @media (max-width: 768px) {
            .progress-steps {
                gap: 8px;
            }

            .progress-step-number {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }

            .progress-step-label {
                font-size: 11px;
            }

            .progress-connector {
                top: 20px;
            }
        }
    </style>

    <!-- UX Component Styles -->
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/components.css">
    <link rel="stylesheet" href="css/ux-components.css">
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <!-- NAVIGATION HEADER -->
    <nav class="main-nav" role="navigation" aria-label="Main navigation">
        <div class="nav-container">
            <!-- Logo -->
            <a href="index.html" class="nav-logo" aria-label="Home">
                üì∏ Photo Sheet Maker
            </a>

            <!-- Navigation Links -->
            <div class="nav-links">
                <a href="index.html" class="nav-link">
                    <span data-i18n="photoMaker">Photo Maker</span>
                </a>
                <a href="photo-editor.html" class="nav-link featured active" aria-current="page">
                    ‚úÇÔ∏è <span data-i18n="photoEditor">Photo Editor</span>
                </a>
                <a href="faq.html" class="nav-link">
                    <span data-i18n="help">Help</span>
                </a>
            </div>

            <!-- Language Selector -->
            <select id="languageSelect" class="nav-language" aria-label="Select language">
                <option value="en">üá∫üá∏ English</option>
                <option value="es">üá™üá∏ Espa√±ol</option>
                <option value="fr">üá´üá∑ Fran√ßais</option>
                <option value="de">üá©üá™ Deutsch</option>
                <option value="pt">üáµüáπ Portugu√™s</option>
                <option value="it">üáÆüáπ Italiano</option>
                <option value="ja">üáØüáµ Êó•Êú¨Ë™û</option>
                <option value="ko">üá∞üá∑ ÌïúÍµ≠Ïñ¥</option>
                <option value="zh">üá®üá≥ ‰∏≠Êñá</option>
                <option value="ar">üá∏üá¶ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</option>
                <option value="hi">üáÆüá≥ ‡§π‡§ø‡§®‡•ç‡§¶‡•Ä</option>
                <option value="ru">üá∑üá∫ –†—É—Å—Å–∫–∏–π</option>
            </select>

            <!-- Mobile Menu Toggle -->
            <button class="mobile-menu-toggle" aria-label="Toggle mobile menu" aria-expanded="false">
                ‚ò∞
            </button>
        </div>
    </nav>

    <!-- Hero Section -->
    <section class="hero">
        <div class="hero-content">
            <div class="hero-icon">
                <div class="hero-camera-icon">
                    <div class="hero-camera-body">
                        <div class="hero-viewfinder"></div>
                        <div class="hero-flash"></div>
                        <div class="hero-lens">
                            <div class="hero-lens-inner">
                                <div class="hero-lens-glare"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <h1 class="hero-title" data-i18n="page_title">Photo Editor</h1>
            <p class="hero-subtitle" data-i18n="page_subtitle">Crop, adjust, and perfect your passport photo</p>
            <a href="index.html" class="hero-cta">
                <span data-i18n="backToHome">‚Üê Back to Home</span>
            </a>
        </div>
        <div class="scroll-indicator">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3" />
            </svg>
        </div>
    </section>

    <!-- Main Content -->
    <div class="main-content">
    <div class="container">
        <!-- Progress Steps -->
        <div id="progressStepsContainer" class="progress-steps-container" style="display: none;" role="navigation" aria-label="Photo editing progress">
            <div class="progress-steps">
                <div id="progressStep1" class="progress-step" data-step="1">
                    <div class="progress-step-number">1</div>
                    <div class="progress-step-label">Upload</div>
                    <div class="progress-connector"></div>
                </div>
                <div id="progressStep2" class="progress-step" data-step="2">
                    <div class="progress-step-number">2</div>
                    <div class="progress-step-label">Adjust</div>
                    <div class="progress-connector"></div>
                </div>
                <div id="progressStep3" class="progress-step" data-step="3">
                    <div class="progress-step-number">3</div>
                    <div class="progress-step-label">Validate</div>
                    <div class="progress-connector"></div>
                </div>
                <div id="progressStep4" class="progress-step" data-step="4">
                    <div class="progress-step-number">4</div>
                    <div class="progress-step-label">Export</div>
                </div>
            </div>
        </div>

        <main id="main-content" class="editor-layout" role="main">
            <!-- Left Panel: Upload & Guidelines -->
            <div class="left-panel">
                <div class="panel">
                    <h3 data-i18n="upload_title">1. Upload Photo</h3>
                    <!-- Upload UI will be dynamically generated by photoHandler.js -->
                    <div id="uploadContainer"></div>
                </div>

                <div class="panel" style="margin-top: 20px;">
                    <h3 data-i18n="guidelines_title">Guidelines</h3>
                    <div class="toggle-group">
                        <div class="toggle-item">
                            <span class="toggle-label" id="faceGuideLabel" data-i18n="face_outline">Face Outline</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="toggleFaceGuide" checked
                                       role="switch" aria-checked="true" aria-labelledby="faceGuideLabel">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div class="toggle-item">
                            <span class="toggle-label" id="gridLabel" data-i18n="grid_scale">Grid with Scale</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="toggleGrid"
                                       role="switch" aria-checked="false" aria-labelledby="gridLabel">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>

                    <div id="instructionsPanel" class="instructions" style="margin-top: 20px;">
                        <div class="instructions-header" onclick="toggleInstructions()" role="button" tabindex="0" aria-expanded="true" aria-controls="instructionsContent">
                            <strong>
                                <span>üìã</span>
                                <span>US Passport Requirements</span>
                            </strong>
                            <span class="collapse-icon" aria-hidden="true">‚ñº</span>
                        </div>
                        <div id="instructionsContent" class="instructions-content">
                            <ul>
                                <li>Head height: 1" to 1-3/8"</li>
                                <li>Face centered horizontally</li>
                                <li>Neutral expression</li>
                                <li>White/off-white background</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Center Column: Canvas + Export -->
            <div>
                <!-- Canvas Panel -->
                <div class="canvas-panel panel" id="canvasPanel">
                    <div id="uploadPrompt">
                        <div style="text-align: center; color: var(--text-secondary);">
                            <div style="font-size: 64px; margin-bottom: 16px;">üì∏</div>
                            <h3 style="font-size: 20px; margin-bottom: 8px; color: var(--text-primary);">Upload a photo to get started</h3>
                            <p>Select a photo from the left panel</p>
                        </div>
                    </div>
                    <div id="canvasContainer" class="canvas-container" style="display: none;"
                         aria-label="Passport photo editing canvas">
                        <canvas id="editCanvas" aria-label="Main editing canvas"></canvas>
                        <canvas id="overlayCanvas" class="overlay-canvas" aria-hidden="true"></canvas>
                        <!-- Touch Gesture Hints for Mobile -->
                        <div class="touch-hints" aria-live="polite">
                            <div class="touch-hint-icon">üëÜ</div>
                            Pinch to zoom ‚Ä¢ Drag to move
                        </div>
                    </div>
                    <div id="photoInfo" style="display: none; text-align: center; margin-top: 16px; padding: 12px; background: rgba(0, 122, 255, 0.05); border-radius: 8px; font-size: 13px; color: var(--text-secondary);">
                        <strong style="color: var(--text-primary);">Photo Specifications</strong><br>
                        <span style="display: inline-block; margin-top: 6px;">
                            <strong>Size:</strong> 2√ó2 inches (51√ó51 mm) ‚Ä¢
                            <strong>Resolution:</strong> 600√ó600 pixels @ 300 DPI
                        </span>
                    </div>
                </div>

                <!-- Export Panel - Separate panel below canvas -->
                <div class="panel" style="margin-top: 20px;">
                    <h3>Export</h3>
                    <button class="btn btn-success" id="exportBtn" disabled
                            aria-label="Use this photo to create a photo sheet - returns to the main photo maker page">
                        ‚úì Create Photo Sheet
                    </button>
                    <button class="btn btn-secondary" id="downloadBtn" disabled
                            aria-label="Download edited photo as JPEG file to your device">
                        ‚¨á Download to Device
                    </button>
                </div>
            </div>

            <!-- Right Panel: Controls -->
            <div class="right-panel">
                <div class="panel">
                    <h3>2. Adjust Photo</h3>

                    <div class="info-badge">
                        <strong>üí° Quick Tips</strong>
                        Drag to pan ‚Ä¢ Scroll to zoom ‚Ä¢ Align face with guides
                    </div>

                    <div class="control-group">
                        <label class="control-label" for="zoomSlider">Zoom</label>
                        <div class="slider-container">
                            <input type="range" id="zoomSlider" class="slider"
                                   min="0.1" max="3" step="0.01" value="1"
                                   aria-label="Zoom level" aria-valuemin="0.1" aria-valuemax="3" aria-valuenow="1" aria-valuetext="100%">
                            <span class="slider-value" id="zoomValue" aria-live="polite">100%</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label class="control-label" for="rotationSlider">Rotation</label>
                        <div class="slider-container">
                            <input type="range" id="rotationSlider" class="slider"
                                   min="-45" max="45" step="0.1" value="0"
                                   aria-label="Rotation angle" aria-valuemin="-45" aria-valuemax="45" aria-valuenow="0" aria-valuetext="0 degrees">
                            <span class="slider-value" id="rotationValue" aria-live="polite">0¬∞</span>
                        </div>
                    </div>

                    <button class="btn btn-secondary" id="resetBtn" disabled
                            aria-label="Reset photo position, zoom, and rotation to defaults">
                        ‚Üª Reset Position
                    </button>
                </div>

                <!-- Background Removal Section - Hidden for future improvements -->
                <!--
                <div class="panel" style="margin-top: 20px;">
                    <h3>3. Background</h3>

                    <button class="btn btn-primary" id="removeBackgroundBtn" disabled>
                        üé® Remove Background
                    </button>

                    <div class="control-group">
                        <label class="control-label">Background Color</label>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                            <button class="bg-color-btn" data-color="#FFFFFF"
                                    style="background: white; border: 2px solid #ddd; height: 40px; border-radius: 8px; cursor: pointer;">
                                White
                            </button>
                            <button class="bg-color-btn" data-color="#F5F5F0"
                                    style="background: #F5F5F0; border: 2px solid #ddd; height: 40px; border-radius: 8px; cursor: pointer;">
                                Off-White
                            </button>
                            <button class="bg-color-btn" data-color="#E8E8E8"
                                    style="background: #E8E8E8; border: 2px solid #ddd; height: 40px; border-radius: 8px; cursor: pointer;">
                                Light Gray
                            </button>
                        </div>
                    </div>

                    <div id="loadingIndicator" class="loading" style="display: none;">
                        <div class="spinner"></div>
                        <div class="processing-text">Processing...</div>
                    </div>
                </div>
                -->

                <div class="panel" style="margin-top: 20px;">
                    <h3>3. Face Validation</h3>

                    <button class="btn btn-primary" id="validateFaceBtn" disabled
                            aria-label="Check if face position meets passport photo requirements">
                        üë§ Check Face Position
                    </button>

                    <div id="validationResults" style="display: none; margin-top: 16px; padding: 16px; border-radius: 8px; font-size: 14px; line-height: 1.6;"
                         role="status" aria-live="polite">
                        <!-- Results will be inserted here -->
                    </div>
                </div>
            </div>
        </main>
    </div>
    </div>

    <!-- Footer Container - Loaded from components/footer.html -->
    <div id="footer-container"></div>

    <!-- Floating Home Button -->
    <a href="index.html" class="floating-home-btn" aria-label="Go to home page" title="Back to Home">
        <div class="floating-camera-icon">
            <div class="floating-camera-body">
                <div class="floating-viewfinder"></div>
                <div class="floating-flash"></div>
                <div class="floating-lens">
                    <div class="floating-lens-inner">
                        <div class="floating-lens-glare"></div>
                    </div>
                </div>
            </div>
        </div>
    </a>

    <!-- Load translations from modular structure -->
    <script type="module" src="translations/index.js"></script>

    <script>
        // Current year will be set by loadFooter() in common.js

        // Canvas size for 2x2 inch photo at 300 DPI
        const CANVAS_SIZE = 600;

        // State variables
        let originalImage = null;
        let currentImage = null;
        let scale = 1;
        let rotation = 0;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let backgroundRemoved = false;

        // DOM elements
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const uploadPrompt = document.getElementById('uploadPrompt');
        const canvasContainer = document.getElementById('canvasContainer');
        const editCanvas = document.getElementById('editCanvas');
        const overlayCanvas = document.getElementById('overlayCanvas');
        const ctx = editCanvas.getContext('2d', { alpha: true });
        const overlayCtx = overlayCanvas.getContext('2d', { alpha: true });

        const zoomSlider = document.getElementById('zoomSlider');
        const zoomValue = document.getElementById('zoomValue');
        const rotationSlider = document.getElementById('rotationSlider');
        const rotationValue = document.getElementById('rotationValue');
        const resetBtn = document.getElementById('resetBtn');
        const removeBackgroundBtn = document.getElementById('removeBackgroundBtn');
        const validateFaceBtn = document.getElementById('validateFaceBtn');
        const validationResults = document.getElementById('validationResults');
        const exportBtn = document.getElementById('exportBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const photoInfo = document.getElementById('photoInfo');

        const toggleFaceGuide = document.getElementById('toggleFaceGuide');
        const toggleGrid = document.getElementById('toggleGrid');

        // UX Enhancement Elements - Progress Steps
        const progressStepsContainer = document.getElementById('progressStepsContainer');
        const progressStep1 = document.getElementById('progressStep1');
        const progressStep2 = document.getElementById('progressStep2');
        const progressStep3 = document.getElementById('progressStep3');
        const progressStep4 = document.getElementById('progressStep4');

        // Initialize canvas
        editCanvas.width = CANVAS_SIZE;
        editCanvas.height = CANVAS_SIZE;
        overlayCanvas.width = CANVAS_SIZE;
        overlayCanvas.height = CANVAS_SIZE;

        // ========================================
        // UX ENHANCEMENTS: Progress Tracking
        // ========================================

        // Progress tracking state
        let currentStep = 1; // 1: Upload, 2: Adjust, 3: Validate, 4: Export

        /**
         * Update progress step indicator
         * @param {number} stepNumber - Step to mark as active (1-4)
         */
        function updateProgressStep(stepNumber) {
            currentStep = stepNumber;

            // Show progress container on first step change
            if (progressStepsContainer.style.display === 'none') {
                progressStepsContainer.style.display = 'block';
            }

            // Reset all steps to default state
            [progressStep1, progressStep2, progressStep3, progressStep4].forEach((step, index) => {
                step.classList.remove('active', 'completed');

                // Mark completed steps
                if (index + 1 < stepNumber) {
                    step.classList.add('completed');
                }
                // Mark active step
                else if (index + 1 === stepNumber) {
                    step.classList.add('active');
                }
            });

            // Track progress in analytics
            if (typeof gtag !== 'undefined') {
                const stepNames = ['Upload', 'Adjust', 'Validate', 'Export'];
                gtag('event', 'progress_step_reached', {
                    'event_category': 'Photo Editor',
                    'event_label': stepNames[stepNumber - 1],
                    'value': stepNumber
                });
            }
        }

        /**
         * Toggle instructions panel collapse/expand
         */
        function toggleInstructions() {
            const panel = document.getElementById('instructionsPanel');
            const header = panel.querySelector('.instructions-header');
            const content = document.getElementById('instructionsContent');

            const isCollapsed = panel.classList.contains('collapsed');

            if (isCollapsed) {
                // Expand
                panel.classList.remove('collapsed');
                header.setAttribute('aria-expanded', 'true');
            } else {
                // Collapse
                panel.classList.add('collapsed');
                header.setAttribute('aria-expanded', 'false');
            }

            // Track toggle action
            if (typeof gtag !== 'undefined') {
                gtag('event', 'instructions_toggled', {
                    'event_category': 'Photo Editor',
                    'event_label': isCollapsed ? 'Expanded' : 'Collapsed'
                });
            }
        }

        // Keyboard accessibility for instructions toggle
        document.addEventListener('DOMContentLoaded', () => {
            const instructionsHeader = document.querySelector('.instructions-header');
            if (instructionsHeader) {
                instructionsHeader.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        toggleInstructions();
                    }
                });
            }
        });

        // ======================================
        // Photo Upload - Now handled by photoHandler module
        // See: js/photoHandler.js and js/photoHandler-editor.js
        // Integration script at bottom of file
        // ======================================


        function showCanvas() {
            uploadPrompt.style.display = 'none';
            canvasContainer.style.display = 'block';
            photoInfo.style.display = 'block';
        }

        function enableControls() {
            resetBtn.disabled = false;
            // removeBackgroundBtn.disabled = false; // Commented out - UI removed
            validateFaceBtn.disabled = false;
            exportBtn.disabled = false;
            downloadBtn.disabled = false;
        }

        function resetTransform() {
            // Calculate initial scale to fit image in canvas
            if (currentImage) {
                // Calculate scale to fit image within canvas while maintaining aspect ratio
                const scaleX = CANVAS_SIZE / currentImage.width;
                const scaleY = CANVAS_SIZE / currentImage.height;
                const autoScale = Math.min(scaleX, scaleY, 1); // Don't scale up, only down if needed

                scale = autoScale;
            } else {
                scale = 1;
            }

            rotation = 0;
            offsetX = 0;
            offsetY = 0;
            zoomSlider.value = scale;
            rotationSlider.value = 0;
            updateSliderValues();

            // Also reset background removal if applied
            if (backgroundRemoved) {
                currentImage = originalImage;
                backgroundRemoved = false;
                // Update button UI only if button exists (UI may be commented out)
                if (removeBackgroundBtn) {
                    removeBackgroundBtn.textContent = 'üé® Remove Background';
                    removeBackgroundBtn.style.background = '';
                    removeBackgroundBtn.disabled = false;
                }
            }
        }

        // Render canvas
        function render() {
            if (!currentImage) return;

            // Clear canvas
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Save context
            ctx.save();

            // Move to center
            ctx.translate(CANVAS_SIZE / 2, CANVAS_SIZE / 2);

            // Apply rotation
            ctx.rotate((rotation * Math.PI) / 180);

            // Apply scale and offset
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            // Draw image centered
            ctx.drawImage(
                currentImage,
                -currentImage.width / 2,
                -currentImage.height / 2,
                currentImage.width,
                currentImage.height
            );

            // Restore context
            ctx.restore();

            // Draw overlay
            drawOverlay();
        }

        // Draw guidelines overlay
        function drawOverlay() {
            overlayCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Face guide (oval) - US passport spec:
            // Photo: 2x2 inches
            // Head: 1 to 1.4 inches (50% to 70% of photo) - we'll show 60% (1.2 inches) as ideal
            if (toggleFaceGuide.checked) {
                overlayCtx.strokeStyle = 'rgba(0, 122, 255, 0.45)';
                overlayCtx.lineWidth = 3;
                overlayCtx.setLineDash([8, 6]);

                const centerX = CANVAS_SIZE / 2;

                // Head height: 60% of photo (1.2" ideal)
                const headHeightPercent = 0.60;
                const radiusY = CANVAS_SIZE * (headHeightPercent / 2); // 30% radius = 60% height

                // Eyes are typically 1/3 down from crown of head
                // If eyes should be at ~37.5% from top (middle of 31-44% range)
                // And eyes are 1/3 down from crown, then crown is at:
                const eyePositionPercent = 0.375;
                const eyesToCrownPercent = headHeightPercent / 3; // ~20%
                const crownPercent = eyePositionPercent - eyesToCrownPercent; // ~17.5%

                // Face center is halfway between crown and chin
                const centerY = CANVAS_SIZE * (crownPercent + (headHeightPercent / 2)); // ~47.5%

                // Face width: typically 70-75% of face height for realistic oval
                const radiusX = radiusY * 0.72; // More realistic face proportions

                overlayCtx.beginPath();
                overlayCtx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
                overlayCtx.stroke();

                // Add reference markers at top and bottom of face guide
                overlayCtx.setLineDash([]);
                overlayCtx.strokeStyle = 'rgba(0, 122, 255, 0.3)';
                overlayCtx.lineWidth = 1;

                // Top of head marker (crown)
                const topY = centerY - radiusY;
                overlayCtx.beginPath();
                overlayCtx.moveTo(centerX - 30, topY);
                overlayCtx.lineTo(centerX + 30, topY);
                overlayCtx.stroke();

                // Add label for crown
                overlayCtx.fillStyle = 'rgba(0, 122, 255, 0.6)';
                overlayCtx.font = '11px -apple-system, sans-serif';
                overlayCtx.fillText('Crown', centerX + 35, topY + 4);

                // Bottom of chin marker
                const bottomY = centerY + radiusY;
                overlayCtx.beginPath();
                overlayCtx.moveTo(centerX - 30, bottomY);
                overlayCtx.lineTo(centerX + 30, bottomY);
                overlayCtx.stroke();

                // Add label for chin
                overlayCtx.fillText('Chin', centerX + 35, bottomY + 4);
            }

            // Grid with scale markings
            if (toggleGrid.checked) {
                overlayCtx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
                overlayCtx.lineWidth = 1;
                overlayCtx.setLineDash([4, 4]);

                // Center cross (most important)
                overlayCtx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                overlayCtx.lineWidth = 2;

                // Vertical center
                overlayCtx.beginPath();
                overlayCtx.moveTo(CANVAS_SIZE / 2, 0);
                overlayCtx.lineTo(CANVAS_SIZE / 2, CANVAS_SIZE);
                overlayCtx.stroke();

                // Horizontal center
                overlayCtx.beginPath();
                overlayCtx.moveTo(0, CANVAS_SIZE / 2);
                overlayCtx.lineTo(CANVAS_SIZE, CANVAS_SIZE / 2);
                overlayCtx.stroke();

                // Thirds grid (lighter)
                overlayCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                overlayCtx.lineWidth = 1;

                // Vertical thirds
                for (let i = 1; i < 3; i++) {
                    const x = (CANVAS_SIZE / 3) * i;
                    overlayCtx.beginPath();
                    overlayCtx.moveTo(x, 0);
                    overlayCtx.lineTo(x, CANVAS_SIZE);
                    overlayCtx.stroke();
                }

                // Horizontal thirds
                for (let i = 1; i < 3; i++) {
                    const y = (CANVAS_SIZE / 3) * i;
                    overlayCtx.beginPath();
                    overlayCtx.moveTo(0, y);
                    overlayCtx.lineTo(CANVAS_SIZE, y);
                    overlayCtx.stroke();
                }

                overlayCtx.setLineDash([]);

                // Helper function to draw text with background for better readability
                function drawScaleText(text, x, y) {
                    overlayCtx.font = 'bold 13px -apple-system, sans-serif';
                    const metrics = overlayCtx.measureText(text);
                    const padding = 3;

                    // Draw semi-transparent background
                    overlayCtx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    overlayCtx.fillRect(
                        x - padding,
                        y - 10 - padding,
                        metrics.width + padding * 2,
                        14 + padding * 2
                    );

                    // Draw white text with shadow for extra contrast
                    overlayCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    overlayCtx.shadowBlur = 3;
                    overlayCtx.shadowOffsetX = 1;
                    overlayCtx.shadowOffsetY = 1;
                    overlayCtx.fillStyle = '#FFFFFF';
                    overlayCtx.fillText(text, x, y);

                    // Reset shadow
                    overlayCtx.shadowColor = 'transparent';
                    overlayCtx.shadowBlur = 0;
                    overlayCtx.shadowOffsetX = 0;
                    overlayCtx.shadowOffsetY = 0;
                }

                // Add scale markings on all edges
                overlayCtx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                overlayCtx.lineWidth = 2;

                // Scale: 2 inches = 600px, so each 0.5" = 150px, each 0.25" = 75px
                const quarterInch = CANVAS_SIZE / 8; // 75px = 0.25"
                const halfInch = CANVAS_SIZE / 4;     // 150px = 0.5"

                // Top edge - horizontal scale
                for (let i = 0; i <= 8; i++) {
                    const x = i * quarterInch;
                    const isMajor = i % 2 === 0; // Every half inch
                    const tickHeight = isMajor ? 16 : 8;

                    overlayCtx.beginPath();
                    overlayCtx.moveTo(x, 0);
                    overlayCtx.lineTo(x, tickHeight);
                    overlayCtx.stroke();

                    if (isMajor && i > 0 && i < 8) {
                        drawScaleText((i * 0.25).toFixed(2) + '"', x - 14, tickHeight + 16);
                    }
                }

                // Bottom edge - horizontal scale
                for (let i = 0; i <= 8; i++) {
                    const x = i * quarterInch;
                    const isMajor = i % 2 === 0;
                    const tickHeight = isMajor ? 16 : 8;

                    overlayCtx.beginPath();
                    overlayCtx.moveTo(x, CANVAS_SIZE);
                    overlayCtx.lineTo(x, CANVAS_SIZE - tickHeight);
                    overlayCtx.stroke();

                    if (isMajor && i > 0 && i < 8) {
                        drawScaleText((i * 0.25).toFixed(2) + '"', x - 14, CANVAS_SIZE - tickHeight - 6);
                    }
                }

                // Left edge - vertical scale
                for (let i = 0; i <= 8; i++) {
                    const y = i * quarterInch;
                    const isMajor = i % 2 === 0;
                    const tickWidth = isMajor ? 16 : 8;

                    overlayCtx.beginPath();
                    overlayCtx.moveTo(0, y);
                    overlayCtx.lineTo(tickWidth, y);
                    overlayCtx.stroke();

                    if (isMajor && i > 0 && i < 8) {
                        overlayCtx.save();
                        drawScaleText((i * 0.25).toFixed(2) + '"', tickWidth + 4, y + 4);
                        overlayCtx.restore();
                    }
                }

                // Right edge - vertical scale
                for (let i = 0; i <= 8; i++) {
                    const y = i * quarterInch;
                    const isMajor = i % 2 === 0;
                    const tickWidth = isMajor ? 16 : 8;

                    overlayCtx.beginPath();
                    overlayCtx.moveTo(CANVAS_SIZE, y);
                    overlayCtx.lineTo(CANVAS_SIZE - tickWidth, y);
                    overlayCtx.stroke();

                    if (isMajor && i > 0 && i < 8) {
                        overlayCtx.save();
                        drawScaleText((i * 0.25).toFixed(2) + '"', CANVAS_SIZE - tickWidth - 32, y + 4);
                        overlayCtx.restore();
                    }
                }
            }
        }

        // Zoom control
        zoomSlider.addEventListener('input', (e) => {
            scale = parseFloat(e.target.value);
            updateSliderValues();
            render();
        });

        // Track zoom changes (throttled)
        let zoomTrackTimeout;
        zoomSlider.addEventListener('change', (e) => {
            clearTimeout(zoomTrackTimeout);
            zoomTrackTimeout = setTimeout(() => {
                if (typeof gtag !== 'undefined') {
                    gtag('event', 'zoom_adjusted', {
                        'event_category': 'Photo Editor',
                        'event_label': 'Zoom Control',
                        'value': Math.round(scale * 100)
                    });
                }
            }, 500);
        });

        // Prevent zoom slider from stealing focus
        zoomSlider.addEventListener('focus', () => {
            if (isDragging) {
                zoomSlider.blur();
            }
        });

        // Rotation control
        rotationSlider.addEventListener('input', (e) => {
            rotation = parseFloat(e.target.value);
            updateSliderValues();
            render();
        });

        // Track rotation changes (throttled)
        let rotationTrackTimeout;
        rotationSlider.addEventListener('change', (e) => {
            clearTimeout(rotationTrackTimeout);
            rotationTrackTimeout = setTimeout(() => {
                if (typeof gtag !== 'undefined') {
                    gtag('event', 'rotation_adjusted', {
                        'event_category': 'Photo Editor',
                        'event_label': 'Rotation Control',
                        'value': Math.round(rotation)
                    });
                }
            }, 500);
        });

        function updateSliderValues() {
            const zoomPercent = Math.round(scale * 100);
            const rotationDegrees = rotation.toFixed(1);

            zoomValue.textContent = zoomPercent + '%';
            rotationValue.textContent = rotationDegrees + '¬∞';

            // Update ARIA attributes for accessibility
            zoomSlider.setAttribute('aria-valuenow', scale);
            zoomSlider.setAttribute('aria-valuetext', zoomPercent + '%');
            rotationSlider.setAttribute('aria-valuenow', rotation);
            rotationSlider.setAttribute('aria-valuetext', rotationDegrees + ' degrees');
        }

        // Mouse wheel zoom (smooth)
        canvasContainer.addEventListener('wheel', (e) => {
            // Prevent zoom while dragging
            if (isDragging) {
                e.preventDefault();
                return;
            }

            e.preventDefault();

            // Increased sensitivity for better zoom out control
            let delta;
            if (e.deltaMode === 1) { // Line mode
                delta = e.deltaY * -0.05;
            } else { // Pixel mode (most common)
                delta = e.deltaY * -0.005; // Increased from 0.001 for better responsiveness
            }

            const newScale = Math.max(0.1, Math.min(3, scale + delta));

            // Only update if scale actually changed
            if (newScale !== scale) {
                scale = newScale;
                zoomSlider.value = scale;
                updateSliderValues();
                render();
            }
        }, { passive: false });

        // Pan with mouse
        canvasContainer.addEventListener('mousedown', (e) => {
            e.preventDefault(); // Prevent any default browser behavior
            isDragging = true;
            dragStartX = e.clientX - offsetX;
            dragStartY = e.clientY - offsetY;
            canvasContainer.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            e.preventDefault(); // Prevent default during drag

            offsetX = e.clientX - dragStartX;
            offsetY = e.clientY - dragStartY;
            render();
        });

        document.addEventListener('mouseup', (e) => {
            if (isDragging) {
                e.preventDefault();
                isDragging = false;
                canvasContainer.style.cursor = 'move';
            }
        });

        // Touch support
        let lastTouchDistance = 0;

        canvasContainer.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                dragStartX = e.touches[0].clientX - offsetX;
                dragStartY = e.touches[0].clientY - offsetY;
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
            }
        });

        canvasContainer.addEventListener('touchmove', (e) => {
            e.preventDefault();

            if (e.touches.length === 1 && isDragging) {
                offsetX = e.touches[0].clientX - dragStartX;
                offsetY = e.touches[0].clientY - dragStartY;
                render();
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (lastTouchDistance > 0) {
                    const delta = (distance - lastTouchDistance) * 0.01;
                    scale = Math.max(0.1, Math.min(3, scale + delta));
                    zoomSlider.value = scale;
                    updateSliderValues();
                    render();
                }

                lastTouchDistance = distance;
            }
        });

        canvasContainer.addEventListener('touchend', () => {
            isDragging = false;
            lastTouchDistance = 0;
        });

        // Reset button
        resetBtn.addEventListener('click', () => {
            resetTransform();
            render();

            // Track reset action
            if (typeof gtag !== 'undefined') {
                gtag('event', 'reset_clicked', {
                    'event_category': 'Photo Editor',
                    'event_label': 'Reset Position'
                });
            }
        });

        // Initialize MediaPipe Selfie Segmentation for background removal
        let selfieSegmentation = null;
        let faceDetection = null;
        let selectedBackgroundColor = '#FFFFFF'; // Default white

        async function initializeSegmentation() {
            try {
                console.log('Starting MediaPipe initialization...');

                // Check if MediaPipe libraries are loaded
                if (typeof SelfieSegmentation === 'undefined') {
                    console.warn('SelfieSegmentation not loaded');
                }
                if (typeof FaceDetection === 'undefined') {
                    console.warn('FaceDetection not loaded');
                }

                // Initialize Selfie Segmentation
                selfieSegmentation = new SelfieSegmentation({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`;
                    }
                });

                selfieSegmentation.setOptions({
                    modelSelection: 0, // 0 for general (0.5-2m), better for close-up passport photos
                });

                // Set up the onResults callback BEFORE using it
                selfieSegmentation.onResults(onSegmentationResults);
                console.log('SelfieSegmentation initialized');

                // Initialize Face Detection
                faceDetection = new FaceDetection({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}`;
                    }
                });

                faceDetection.setOptions({
                    model: 'short', // 'short' for faces within 2 meters
                    minDetectionConfidence: 0.5
                });

                // Set up face detection callback
                faceDetection.onResults(onFaceDetectionResults);
                console.log('FaceDetection initialized');

                console.log('MediaPipe libraries initialized successfully');
            } catch (error) {
                console.error('Failed to initialize MediaPipe:', error);
                // Face detection is still available even if initialization partially fails
            }
        }

        // Store the results for processing
        let currentSegmentationResults = null;
        let currentFaceResults = null;

        function onSegmentationResults(results) {
            currentSegmentationResults = results;
        }

        function onFaceDetectionResults(results) {
            currentFaceResults = results;
        }

        // Initialize on page load
        window.addEventListener('load', initializeSegmentation);

        // Toggle controls
        toggleFaceGuide.addEventListener('change', () => {
            render();

            // Update ARIA and track event
            toggleFaceGuide.setAttribute('aria-checked', toggleFaceGuide.checked);
            if (typeof gtag !== 'undefined') {
                gtag('event', 'toggle_face_guide', {
                    'event_category': 'Photo Editor',
                    'event_label': 'Face Outline Guide',
                    'value': toggleFaceGuide.checked ? 1 : 0
                });
            }
        });

        toggleGrid.addEventListener('change', () => {
            render();

            // Update ARIA and track event
            toggleGrid.setAttribute('aria-checked', toggleGrid.checked);
            if (typeof gtag !== 'undefined') {
                gtag('event', 'toggle_grid', {
                    'event_category': 'Photo Editor',
                    'event_label': 'Grid with Scale',
                    'value': toggleGrid.checked ? 1 : 0
                });
            }
        });

        // Face validation using MediaPipe Face Detection
        validateFaceBtn.addEventListener('click', async () => {
            console.log('Face validation button clicked');
            console.log('Current image:', currentImage);
            console.log('Face detection initialized:', faceDetection);

            // Track face validation click
            if (typeof gtag !== 'undefined') {
                gtag('event', 'face_validation_started', {
                    'event_category': 'Photo Editor',
                    'event_label': 'Face Validation'
                });
            }

            // Update progress to step 3 (Validate)
            updateProgressStep(3);

            if (!currentImage) {
                console.error('No image loaded');
                return;
            }

            if (!faceDetection) {
                console.error('Face detection not initialized');
                validationResults.style.display = 'block';
                validationResults.style.background = '#FFF3CD';
                validationResults.style.borderLeft = '4px solid #FFA500';
                validationResults.innerHTML = `
                    <strong style="color: #856404;">‚ö†Ô∏è Face Detection Not Ready</strong>
                    <p style="color: #856404; margin-top: 8px;">Face detection is still loading. Please wait a moment and try again.</p>
                    <p style="color: #856404; margin-top: 8px; font-size: 12px;">If this persists, try refreshing the page.</p>
                `;
                return;
            }

            validationResults.style.display = 'block';
            validationResults.innerHTML = '<div class="spinner" style="width: 20px; height: 20px; margin: 0 auto;"></div><p style="text-align: center; margin-top: 10px;">Analyzing face position...</p>';
            validateFaceBtn.disabled = true;

            try {
                // Create temporary canvas for processing
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = currentImage.width;
                tempCanvas.height = currentImage.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(currentImage, 0, 0);

                // Reset results
                currentFaceResults = null;

                // Process with MediaPipe
                await faceDetection.send({image: tempCanvas});

                // Wait for results (with timeout)
                const maxWait = 5000; // 5 seconds
                const startTime = Date.now();

                while (!currentFaceResults && (Date.now() - startTime) < maxWait) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                if (!currentFaceResults || !currentFaceResults.detections || currentFaceResults.detections.length === 0) {
                    validationResults.style.background = '#FFF3CD';
                    validationResults.style.borderLeft = '4px solid #FFA500';
                    validationResults.innerHTML = `
                        <strong style="color: #856404;">‚ö†Ô∏è No Face Detected</strong>
                        <p style="color: #856404; margin-top: 8px;">Make sure:</p>
                        <ul style="color: #856404; margin-left: 20px; margin-top: 8px;">
                            <li>Your face is clearly visible</li>
                            <li>Good lighting conditions</li>
                            <li>Face is centered in the photo</li>
                            <li>Zoom in to make face larger</li>
                        </ul>
                    `;
                    validateFaceBtn.disabled = false;
                    return;
                }

                // ========================================
                // COMPREHENSIVE FACE VALIDATION SYSTEM
                // ========================================

                const face = currentFaceResults.detections[0];
                const bbox = face.boundingBox;
                const landmarks = face.landmarks;

                // Debug info object
                const debugInfo = {
                    method: 'unknown',
                    hasEyes: false,
                    hasNose: false,
                    hasMouth: false,
                    bboxCoverage: 'unknown'
                };

                // ========================================
                // STEP 1: Extract all available landmarks
                // ========================================
                let rightEye = null, leftEye = null, noseTip = null, mouthCenter = null;

                if (landmarks && landmarks.length >= 2) {
                    rightEye = landmarks[0];  // Right eye
                    leftEye = landmarks[1];   // Left eye
                    debugInfo.hasEyes = true;

                    if (landmarks.length >= 3) {
                        noseTip = landmarks[2];
                        debugInfo.hasNose = true;
                    }
                    if (landmarks.length >= 4) {
                        mouthCenter = landmarks[3];
                        debugInfo.hasMouth = true;
                    }
                }

                // ========================================
                // STEP 2: Convert bbox to pixel coordinates
                // ========================================
                const bboxLeft = (bbox.xCenter - bbox.width / 2) * currentImage.width;
                const bboxTop = (bbox.yCenter - bbox.height / 2) * currentImage.height;
                const bboxRight = (bbox.xCenter + bbox.width / 2) * currentImage.width;
                const bboxBottom = (bbox.yCenter + bbox.height / 2) * currentImage.height;
                const bboxWidthPx = bboxRight - bboxLeft;
                const bboxHeightPx = bboxBottom - bboxTop;
                const bboxCenterX = (bboxLeft + bboxRight) / 2;
                const bboxCenterY = (bboxTop + bboxBottom) / 2;

                // ========================================
                // STEP 3: Determine head boundaries using multi-strategy approach
                // ========================================
                let crownYPx, chinYPx, headCenterXPx, headCenterYPx;
                let eyeYPx = null, noseYPx = null, mouthYPx = null;

                if (rightEye && leftEye) {
                    // Strategy: Eye-landmark based (most accurate)
                    debugInfo.method = 'eye-landmark';

                    const eyeCenterX = (rightEye.x + leftEye.x) / 2;
                    const eyeCenterY = (rightEye.y + leftEye.y) / 2;
                    eyeYPx = eyeCenterY * currentImage.height;
                    headCenterXPx = eyeCenterX * currentImage.width;

                    // Get additional landmarks for better accuracy
                    if (noseTip) {
                        noseYPx = noseTip.y * currentImage.height;
                    }
                    if (mouthCenter) {
                        mouthYPx = mouthCenter.y * currentImage.height;
                    }

                    // ANATOMICAL PROPORTIONS (adult human head):
                    // - Crown to eyes: ~43% of total head height
                    // - Eyes to nose: ~17% of total head height
                    // - Nose to mouth: ~10% of total head height
                    // - Mouth to chin: ~30% of total head height

                    // Method A: If we have mouth, use eye-to-mouth distance
                    if (mouthYPx) {
                        const eyeToMouthPx = mouthYPx - eyeYPx;
                        // Eye to mouth is ~27% of head, so full head = eyeToMouth / 0.27
                        const estimatedHeadHeight = eyeToMouthPx / 0.27;

                        // Crown is 43% of head above eyes
                        crownYPx = eyeYPx - (estimatedHeadHeight * 0.43);
                        // Chin is 57% of head below eyes (100% - 43%)
                        chinYPx = eyeYPx + (estimatedHeadHeight * 0.57);

                        debugInfo.bboxCoverage = 'eye-mouth-based';
                    }
                    // Method B: If we have nose but no mouth
                    else if (noseYPx) {
                        const eyeToNosePx = noseYPx - eyeYPx;
                        // Eye to nose is ~17% of head, so full head = eyeToNose / 0.17
                        const estimatedHeadHeight = eyeToNosePx / 0.17;

                        crownYPx = eyeYPx - (estimatedHeadHeight * 0.43);
                        chinYPx = eyeYPx + (estimatedHeadHeight * 0.57);

                        debugInfo.bboxCoverage = 'eye-nose-based';
                    }
                    // Method C: Use bbox bottom as chin approximation
                    else {
                        // Bbox bottom is usually close to chin
                        chinYPx = bboxBottom;
                        const eyeToChinPx = chinYPx - eyeYPx;
                        // Eye to chin is ~57% of head, so full head = eyeToChin / 0.57
                        const estimatedHeadHeight = eyeToChinPx / 0.57;

                        crownYPx = eyeYPx - (estimatedHeadHeight * 0.43);

                        debugInfo.bboxCoverage = 'eye-bbox-based';
                    }

                    // Head center Y is midpoint between crown and chin
                    headCenterYPx = (crownYPx + chinYPx) / 2;

                } else {
                    // Strategy: Bbox-only based (fallback)
                    debugInfo.method = 'bbox-only';

                    headCenterXPx = bboxCenterX;

                    // Assumption: MediaPipe bbox typically captures from hairline/forehead to chin
                    // This is roughly 85-90% of full head (crown to chin)
                    // We need to add ~10-15% above the bbox top for full crown

                    const extraAbove = bboxHeightPx * 0.12; // Add 12% above for crown
                    crownYPx = bboxTop - extraAbove;
                    chinYPx = bboxBottom;
                    headCenterYPx = (crownYPx + chinYPx) / 2;

                    debugInfo.bboxCoverage = 'bbox-only-with-crown-estimate';
                }

                const headHeightPx = chinYPx - crownYPx;

                // ========================================
                // STEP 4: Transform source coordinates to canvas coordinates
                // ========================================
                // The canvas transformation is:
                // 1. Image is centered at canvas center
                // 2. Rotation is applied around canvas center
                // 3. Scale is applied
                // 4. Offset (pan) is applied

                const canvasCenterX = CANVAS_SIZE / 2;
                const canvasCenterY = CANVAS_SIZE / 2;

                // Helper function to transform a point from source to canvas
                function transformToCanvas(sourceX, sourceY) {
                    // Position relative to source image center
                    const relX = sourceX - currentImage.width / 2;
                    const relY = sourceY - currentImage.height / 2;

                    // Apply rotation around origin (0,0)
                    const rotRad = (rotation * Math.PI) / 180;
                    const cosRot = Math.cos(rotRad);
                    const sinRot = Math.sin(rotRad);
                    const rotX = relX * cosRot - relY * sinRot;
                    const rotY = relX * sinRot + relY * cosRot;

                    // Apply scale
                    const scaledX = rotX * scale;
                    const scaledY = rotY * scale;

                    // Apply offset and translate to canvas center
                    const canvasX = canvasCenterX + scaledX + offsetX;
                    const canvasY = canvasCenterY + scaledY + offsetY;

                    return { x: canvasX, y: canvasY };
                }

                // Transform head points to canvas
                const canvasHeadCenter = transformToCanvas(headCenterXPx, headCenterYPx);
                const canvasCrown = transformToCanvas(headCenterXPx, crownYPx);
                const canvasChin = transformToCanvas(headCenterXPx, chinYPx);

                // Head height on canvas (accounting for rotation)
                const canvasHeadHeight = Math.abs(canvasChin.y - canvasCrown.y);

                // Use transformed coordinates
                const canvasHeadCenterX = canvasHeadCenter.x;
                const canvasHeadCenterY = canvasHeadCenter.y;
                const canvasCrownY = canvasCrown.y;
                const canvasChinY = canvasChin.y;

                // ========================================
                // STEP 5: Calculate percentages and validate
                // ========================================

                // Calculate head height as percentage of canvas
                const headHeightPercent = (canvasHeadHeight / CANVAS_SIZE) * 100;

                // Face center position as percentage from top/left
                const faceCenterYPercent = (canvasHeadCenterY / CANVAS_SIZE) * 100;
                const faceCenterXPercent = (canvasHeadCenterX / CANVAS_SIZE) * 100;

                // Crown and chin positions as percentage (for detailed feedback)
                const crownYPercent = (canvasCrownY / CANVAS_SIZE) * 100;
                const chinYPercent = (canvasChinY / CANVAS_SIZE) * 100;

                // ========================================
                // STEP 6: Define target values (matching our oval guideline)
                // ========================================

                const targetHeadHeight = 60;        // Our oval is 60% tall
                const targetVerticalCenter = 47.5;  // Our oval center at 47.5%
                const targetHorizontalCenter = 50;  // Centered at 50%
                const targetCrownY = 17.5;          // Our oval crown at 17.5%
                const targetChinY = 77.5;           // Our oval chin at 77.5%

                // ========================================
                // STEP 7: Perform validation with progressive tolerance
                // ========================================

                const results = [];
                let allGood = true;

                // SIZE VALIDATION
                const heightDiff = Math.abs(headHeightPercent - targetHeadHeight);
                if (headHeightPercent < 40) {
                    results.push({ status: 'error', text: '‚ùå Face too small - zoom in significantly' });
                    allGood = false;
                } else if (headHeightPercent > 80) {
                    results.push({ status: 'error', text: '‚ùå Face too large - zoom out significantly' });
                    allGood = false;
                } else if (heightDiff > 15) {
                    if (headHeightPercent < targetHeadHeight) {
                        results.push({ status: 'warning', text: `‚ö†Ô∏è Face small (${headHeightPercent.toFixed(0)}%) - zoom in more` });
                    } else {
                        results.push({ status: 'warning', text: `‚ö†Ô∏è Face large (${headHeightPercent.toFixed(0)}%) - zoom out more` });
                    }
                } else if (heightDiff > 8) {
                    if (headHeightPercent < targetHeadHeight) {
                        results.push({ status: 'success', text: `‚úì Face size acceptable - could zoom in slightly to ${targetHeadHeight}%` });
                    } else {
                        results.push({ status: 'success', text: `‚úì Face size acceptable - could zoom out slightly to ${targetHeadHeight}%` });
                    }
                } else if (heightDiff > 3) {
                    results.push({ status: 'success', text: `‚úì Face size good (${headHeightPercent.toFixed(1)}% vs ${targetHeadHeight}%)` });
                } else {
                    results.push({ status: 'success', text: `‚úì Face size perfect! (${headHeightPercent.toFixed(1)}%)` });
                }

                // VERTICAL POSITION VALIDATION
                const verticalDiff = Math.abs(faceCenterYPercent - targetVerticalCenter);
                const crownDiff = Math.abs(crownYPercent - targetCrownY);
                const chinDiff = Math.abs(chinYPercent - targetChinY);

                if (faceCenterYPercent < 25 || crownYPercent < 0) {
                    results.push({ status: 'error', text: '‚ùå Face too high - pan down significantly' });
                    allGood = false;
                } else if (faceCenterYPercent > 70 || chinYPercent > 100) {
                    results.push({ status: 'error', text: '‚ùå Face too low - pan up significantly' });
                    allGood = false;
                } else if (verticalDiff > 12) {
                    if (faceCenterYPercent < targetVerticalCenter) {
                        results.push({ status: 'warning', text: `‚ö†Ô∏è Face high (${faceCenterYPercent.toFixed(0)}%) - pan down to ~${targetVerticalCenter}%` });
                    } else {
                        results.push({ status: 'warning', text: `‚ö†Ô∏è Face low (${faceCenterYPercent.toFixed(0)}%) - pan up to ~${targetVerticalCenter}%` });
                    }
                } else if (verticalDiff > 6) {
                    if (faceCenterYPercent < targetVerticalCenter) {
                        results.push({ status: 'success', text: `‚úì Vertical acceptable - pan down slightly for perfect alignment` });
                    } else {
                        results.push({ status: 'success', text: `‚úì Vertical acceptable - pan up slightly for perfect alignment` });
                    }
                } else if (verticalDiff > 2) {
                    results.push({ status: 'success', text: `‚úì Vertical position good (${faceCenterYPercent.toFixed(1)}%)` });
                } else {
                    results.push({ status: 'success', text: `‚úì Vertical position perfect! (${faceCenterYPercent.toFixed(1)}%)` });
                }

                // HORIZONTAL POSITION VALIDATION
                const horizontalDiff = Math.abs(faceCenterXPercent - targetHorizontalCenter);
                if (faceCenterXPercent < 25) {
                    results.push({ status: 'error', text: '‚ùå Face too far left - pan right significantly' });
                    allGood = false;
                } else if (faceCenterXPercent > 75) {
                    results.push({ status: 'error', text: '‚ùå Face too far right - pan left significantly' });
                    allGood = false;
                } else if (horizontalDiff > 12) {
                    if (faceCenterXPercent < targetHorizontalCenter) {
                        results.push({ status: 'warning', text: `‚ö†Ô∏è Face left (${faceCenterXPercent.toFixed(0)}%) - pan right` });
                    } else {
                        results.push({ status: 'warning', text: `‚ö†Ô∏è Face right (${faceCenterXPercent.toFixed(0)}%) - pan left` });
                    }
                } else if (horizontalDiff > 5) {
                    results.push({ status: 'success', text: `‚úì Horizontal acceptable - minor adjustment possible` });
                } else if (horizontalDiff > 2) {
                    results.push({ status: 'success', text: `‚úì Horizontally centered (${faceCenterXPercent.toFixed(1)}%)` });
                } else {
                    results.push({ status: 'success', text: `‚úì Perfectly centered horizontally! (${faceCenterXPercent.toFixed(1)}%)` });
                }

                // ========================================
                // STEP 8: Display results with detailed feedback
                // ========================================
                const bgColor = allGood ? '#D4EDDA' : '#FFF3CD';
                const borderColor = allGood ? '#28A745' : '#FFA500';
                validationResults.style.background = bgColor;
                validationResults.style.borderLeft = `4px solid ${borderColor}`;

                // Track validation results
                if (typeof gtag !== 'undefined') {
                    gtag('event', 'face_validation_completed', {
                        'event_category': 'Photo Editor',
                        'event_label': allGood ? 'Perfect Alignment' : 'Needs Adjustment',
                        'value': allGood ? 1 : 0
                    });
                }

                let html = allGood
                    ? '<strong style="color: #155724;">üéâ Perfect! Your photo aligns with the guideline</strong>'
                    : '<strong style="color: #856404;">üìä Face Position Analysis</strong>';

                html += '<ul style="margin: 12px 0 0 20px; padding: 0;">';
                results.forEach(result => {
                    const color = result.status === 'success' ? '#155724' :
                                 result.status === 'warning' ? '#856404' : '#721C24';
                    html += `<li style="color: ${color}; margin: 6px 0;">${result.text}</li>`;
                });
                html += '</ul>';

                // Add toggle button for detailed stats
                html += `
                    <div style="text-align: center; margin-top: 12px;">
                        <button id="toggleStatsBtn" style="padding: 8px 16px; border: 1px solid #007AFF; background: white; color: #007AFF; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.2s;">
                            ü§ì Show Detailed Stats
                        </button>
                    </div>
                `;

                // Build detection method description
                let methodDesc = '';
                if (debugInfo.method === 'eye-landmark') {
                    if (debugInfo.bboxCoverage === 'eye-mouth-based') {
                        methodDesc = 'üëÅÔ∏èüëÑ Eye+Mouth Landmarks (Highest Accuracy)';
                    } else if (debugInfo.bboxCoverage === 'eye-nose-based') {
                        methodDesc = 'üëÅÔ∏èüëÉ Eye+Nose Landmarks (High Accuracy)';
                    } else {
                        methodDesc = 'üëÅÔ∏è Eye Landmarks (Good Accuracy)';
                    }
                } else {
                    methodDesc = 'üì¶ Bounding Box Only (Standard)';
                }

                // Detailed measurements section (hidden by default)
                html += `
                    <div id="detailedStats" style="display: none; margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(0,0,0,0.1); font-size: 12px; color: #666;">
                        <div style="background: rgba(0, 122, 255, 0.05); padding: 8px; border-radius: 6px; margin-bottom: 10px;">
                            <strong style="color: #007AFF;">üîç Detection:</strong> ${methodDesc}
                        </div>

                        <strong>üìè Current Measurements:</strong><br>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin: 6px 0;">
                            <span>‚Ä¢ Head height:</span> <span style="font-weight: 600;">${headHeightPercent.toFixed(1)}%</span>
                            <span>‚Ä¢ Center vertical:</span> <span style="font-weight: 600;">${faceCenterYPercent.toFixed(1)}%</span>
                            <span>‚Ä¢ Center horizontal:</span> <span style="font-weight: 600;">${faceCenterXPercent.toFixed(1)}%</span>
                        </div>

                        <strong style="margin-top: 8px; display: block;">üéØ Target Guideline:</strong><br>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin: 6px 0;">
                            <span>‚Ä¢ Head height:</span> <span style="color: #007AFF; font-weight: 600;">${targetHeadHeight}%</span>
                            <span>‚Ä¢ Center vertical:</span> <span style="color: #007AFF; font-weight: 600;">${targetVerticalCenter}%</span>
                            <span>‚Ä¢ Center horizontal:</span> <span style="color: #007AFF; font-weight: 600;">${targetHorizontalCenter}%</span>
                        </div>

                        <strong style="margin-top: 8px; display: block;">üìç Detailed Positions:</strong><br>
                        <div style="display: grid; grid-template-columns: auto 1fr 1fr; gap: 4px 8px; margin: 6px 0; font-size: 11px;">
                            <span></span><span style="text-align: center; font-weight: 600;">Current</span><span style="text-align: center; font-weight: 600; color: #007AFF;">Target</span>
                            <span>Crown:</span><span style="text-align: center;">${crownYPercent.toFixed(1)}%</span><span style="text-align: center; color: #007AFF;">${targetCrownY}%</span>
                            <span>Chin:</span><span style="text-align: center;">${chinYPercent.toFixed(1)}%</span><span style="text-align: center; color: #007AFF;">${targetChinY}%</span>
                        </div>

                        <div style="margin-top: 10px; padding: 8px; background: rgba(52, 199, 89, 0.05); border-radius: 6px; font-size: 11px; line-height: 1.5;">
                            <strong style="color: #28A745;">üí° Tips:</strong><br>
                            ‚Ä¢ Align crown & chin with blue oval markers<br>
                            ‚Ä¢ Use mouse wheel or slider to zoom<br>
                            ‚Ä¢ Click and drag to pan the image
                        </div>
                    </div>
                `;

                validationResults.innerHTML = html;

                // Add event listener for toggle button
                const toggleBtn = document.getElementById('toggleStatsBtn');
                if (toggleBtn) {
                    toggleBtn.addEventListener('click', () => {
                        const detailedStats = document.getElementById('detailedStats');
                        if (detailedStats) {
                            const isHidden = detailedStats.style.display === 'none';
                            detailedStats.style.display = isHidden ? 'block' : 'none';
                            toggleBtn.textContent = isHidden ? 'üìä Hide Detailed Stats' : 'ü§ì Show Detailed Stats';
                            toggleBtn.style.background = isHidden ? '#007AFF' : 'white';
                            toggleBtn.style.color = isHidden ? 'white' : '#007AFF';
                        }
                    });
                }

            } catch (error) {
                console.error('Face validation failed:', error);
                validationResults.style.background = '#F8D7DA';
                validationResults.style.borderLeft = '4px solid #DC3545';
                validationResults.innerHTML = `
                    <strong style="color: #721C24;">‚ùå Validation Failed</strong>
                    <p style="color: #721C24; margin-top: 8px;">${error.message}</p>
                    <p style="color: #721C24; margin-top: 8px;">Please try again or use a different photo.</p>
                `;
            } finally {
                validateFaceBtn.disabled = false;
            }
        });

        // ======================================
        // Export and Download buttons - Now handled by photoHandler module
        // See integration script at bottom of file
        // ======================================


        // ========================================
        // LOCALIZATION SYSTEM
        // ========================================

        // Translations are now loaded from translations/index.js module
        // The module automatically assigns to window.translations
        // Keeping this as a fallback for file:// protocol compatibility
        const translations = window.translations || {};

        // Get or set language preference
        function getLanguage() {
            return localStorage.getItem('preferredLanguage') || 'en';
        }

        function setLanguage(lang) {
            localStorage.setItem('preferredLanguage', lang);
        }

        // Apply translations to the page
        function applyTranslations(lang) {
            // Ensure translations object exists
            if (!translations || typeof translations !== 'object') {
                console.warn('Translations not loaded yet, waiting...');
                return;
            }

            const trans = translations[lang] || translations.en;

            // Safety check - ensure trans has data
            if (!trans || typeof trans !== 'object') {
                console.warn(`Translation for language "${lang}" not found, using English fallback`);
                return;
            }

            // Update all elements with data-i18n attribute
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (trans[key]) {
                    element.textContent = trans[key];
                }
            });

            // Update document title
            if (trans.page_title) {
                document.title = trans.page_title + " - Passport Photo Maker";
            }

            // Track language change
            if (typeof gtag !== 'undefined') {
                gtag('event', 'language_changed', {
                    'event_category': 'Localization',
                    'event_label': lang
                });
            }
        }

        // Language selector event listener
        const languageSelect = document.getElementById('languageSelect');
        if (languageSelect) {
            // Set initial language
            const currentLang = getLanguage();
            languageSelect.value = currentLang;
            applyTranslations(currentLang);

            // Handle language change
            languageSelect.addEventListener('change', (e) => {
                const newLang = e.target.value;
                setLanguage(newLang);
                applyTranslations(newLang);

                // Optional: Show confirmation
                console.log(`Language changed to: ${newLang}`);
            });
        }

        // Apply translations on page load
        document.addEventListener('DOMContentLoaded', () => {
            const lang = getLanguage();
            if (languageSelect) {
                languageSelect.value = lang;
            }
            applyTranslations(lang);
        });
    </script>

    <!-- UX Components Initialization -->
    <script type="module">
        import { initMobileNav, initStickyNav } from './js/ux-components.js';

        // Import common utilities
        import { initCommon } from './js/common.js';

        // Initialize basic UX components
        document.addEventListener('DOMContentLoaded', async () => {
            // Load footer first
            await initCommon();

            initMobileNav();
            initStickyNav();
        });
    </script>

    <!-- ================================================== -->
    <!-- Photo Handler Module Integration -->
    <!-- ================================================== -->
    <script type="module">
        import { PhotoStorage } from './js/photoHandler.js';
        import {
            initPhotoEditorUpload,
            handleUsePhoto,
            handleDownloadPhoto
        } from './js/photoHandler-editor.js';

        // Photo handler and storage instances
        let photoHandler = null;
        const photoStorage = new PhotoStorage();

        // Initialize function
        function initializePhotoHandler() {
            // Get current language for translations
            const currentLang = getLanguage();
            const trans = translations[currentLang] || translations.en;

            // Initialize photo upload with image loading callback
            photoHandler = initPhotoEditorUpload(
                trans,
                (image, dataURL, metadata) => {
                    console.log('Photo loaded via photoHandler:', metadata);

                    // Set images for editor
                    originalImage = image;
                    currentImage = image;

                    // Initialize editor with the image
                    resetTransform();
                    render();
                    enableControls();

                    // Show canvas area
                    const uploadPrompt = document.getElementById('uploadPrompt');
                    const canvasContainer = document.getElementById('canvasContainer');
                    const photoInfo = document.getElementById('photoInfo');

                    if (uploadPrompt) uploadPrompt.style.display = 'none';
                    if (canvasContainer) canvasContainer.style.display = 'block';
                    if (photoInfo) photoInfo.style.display = 'block';
                },
                updateProgressStep  // Pass progress update function
            );

            console.log('Photo handler initialized for photo editor');
        }

        // Call immediately if DOM already loaded, otherwise wait for DOMContentLoaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializePhotoHandler);
        } else {
            // DOM is already loaded, initialize immediately
            initializePhotoHandler();
        }

        // Connect the "Use Photo" button (Create Photo Sheet)
        const exportBtn = document.getElementById('exportBtn');
        if (exportBtn) {
            exportBtn.addEventListener('click', () => {
                console.log('Use Photo clicked');

                const editCanvas = document.getElementById('editCanvas');
                if (editCanvas) {
                    handleUsePhoto(editCanvas, photoStorage, updateProgressStep);
                } else {
                    console.error('Edit canvas not found');
                }
            });
        }

        // Connect the "Download" button
        const downloadBtn = document.getElementById('downloadBtn');
        if (downloadBtn) {
            downloadBtn.addEventListener('click', () => {
                console.log('Download clicked');

                const editCanvas = document.getElementById('editCanvas');
                if (editCanvas) {
                    handleDownloadPhoto(editCanvas, 'passport-photo-edited.jpg');
                } else {
                    console.error('Edit canvas not found');
                }
            });
        }

        // Update upload text when language changes
        // Hook into existing applyTranslations function
        const originalApplyTranslations = window.applyTranslations;
        if (typeof originalApplyTranslations === 'function') {
            window.applyTranslations = function(lang) {
                // Call original translation function
                originalApplyTranslations(lang);

                // Update photo handler text
                if (photoHandler && translations[lang]) {
                    const trans = translations[lang];
                    photoHandler.updateText({
                        uploadText: trans.upload_text || 'Choose Your Photo',
                        uploadHint: trans.upload_hint || 'Click or drag and drop',
                        successMessage: trans.uploadSuccess || 'Photo uploaded successfully'
                    });
                }
            };
        }

        // Make instances accessible globally for debugging
        window.photoHandler = photoHandler;
        window.photoStorage = photoStorage;
    </script>
</body>
</html>
