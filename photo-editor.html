<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Primary Meta Tags -->
    <title>Photo Editor - Passport Photo Maker</title>
    <meta name="title" content="Photo Editor - Passport Photo Maker">
    <meta name="description" content="Edit and prepare your passport photo with professional tools. Adjust, crop, validate face position with AI. Create perfect passport photos.">
    <meta name="keywords" content="passport photo editor, photo crop tool, face validation, passport photo preparation, photo adjustment, photo editor online">
    <meta name="author" content="Photo Sheet Maker">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://aniltv06.github.io/passportphotosheet/photo-editor.html">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://aniltv06.github.io/passportphotosheet/photo-editor.html">
    <meta property="og:title" content="Photo Editor - Passport Photo Maker">
    <meta property="og:description" content="Professional passport photo editor with AI face validation. Adjust, crop, and prepare perfect passport photos.">
    <meta property="og:image" content="https://aniltv06.github.io/passportphotosheet/og-image.jpg">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://aniltv06.github.io/passportphotosheet/photo-editor.html">
    <meta name="twitter:title" content="Photo Editor - Passport Photo Maker">
    <meta name="twitter:description" content="Professional passport photo editor with AI face validation.">

    <!-- Theme and Mobile -->
    <meta name="theme-color" content="#007AFF">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Photo Editor">

    <!-- Favicons -->
    <link rel="icon" type="image/x-icon" href="favicon/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png">

    <!-- Dynamic Cache Control - Automatically manages cache based on environment -->
    <!-- Development: Disables cache for easier testing -->
    <!-- Production: Enables cache for better performance -->
    <script type="module" src="js/meta-loader.js"></script>

    <!-- MediaPipe Libraries for Face Detection with CDN Fallback -->
    <script>
        // CDN Fallback System for MediaPipe
        // Tries multiple CDNs and gracefully degrades if all fail

        (function() {
            const cdnSources = {
                selfieSegmentation: [
                    'https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation@0.1/selfie_segmentation.js',
                    'https://unpkg.com/@mediapipe/selfie_segmentation@0.1/selfie_segmentation.js'
                ],
                faceDetection: [
                    'https://cdn.jsdelivr.net/npm/@mediapipe/face_detection@0.4/face_detection.js',
                    'https://unpkg.com/@mediapipe/face_detection@0.4/face_detection.js'
                ]
            };

            let loadAttempts = {
                selfieSegmentation: 0,
                faceDetection: 0
            };

            // Load script with fallback
            function loadScriptWithFallback(urls, libraryName, callback) {
                const currentIndex = loadAttempts[libraryName];

                if (currentIndex >= urls.length) {
                    console.error(`Failed to load ${libraryName} from all CDN sources`);
                    callback(false);
                    return;
                }

                const script = document.createElement('script');
                script.src = urls[currentIndex];

                script.onload = () => {
                    console.log(`‚úì Loaded ${libraryName} from CDN ${currentIndex + 1}`);
                    callback(true);
                };

                script.onerror = () => {
                    console.warn(`‚úó Failed to load ${libraryName} from CDN ${currentIndex + 1}, trying next...`);
                    loadAttempts[libraryName]++;

                    // Track CDN failure
                    if (typeof gtag !== 'undefined') {
                        gtag('event', 'cdn_fallback', {
                            'event_category': 'Performance',
                            'event_label': libraryName,
                            'value': currentIndex
                        });
                    }

                    // Try next CDN
                    loadScriptWithFallback(urls, libraryName, callback);
                };

                document.head.appendChild(script);
            }

            // Load both libraries
            let selfieLoaded = false;
            let faceLoaded = false;

            function checkAllLoaded() {
                if (selfieLoaded !== null && faceLoaded !== null) {
                    if (!selfieLoaded || !faceLoaded) {
                        // At least one library failed to load
                        console.warn('MediaPipe libraries unavailable - Face validation will be limited');
                        window.mediaPipeAvailable = false;

                        // Show user notification
                        document.addEventListener('DOMContentLoaded', () => {
                            const validationResults = document.getElementById('validationResults');
                            if (validationResults) {
                                const lang = localStorage.getItem('preferredLanguage') || 'en';
                                const trans = window.translations?.[lang] || window.translations?.en || {};

                                validationResults.style.display = 'block';
                                validationResults.style.background = '#FFF3CD';
                                validationResults.style.borderLeft = '4px solid #FFA500';
                                validationResults.innerHTML = `
                                    <strong style="color: #856404;">${trans.faceValidationLimitedTitle || '‚ö†Ô∏è Limited Functionality'}</strong>
                                    <p style="color: #856404; margin-top: 8px; font-size: 13px;">
                                        ${trans.faceValidationLimitedDesc || 'Face detection libraries couldn\'t be loaded. Face validation feature is unavailable. All other editing features work normally.'}
                                    </p>
                                `;
                            }
                        });
                    } else {
                        window.mediaPipeAvailable = true;
                    }
                }
            }

            // Start loading
            loadScriptWithFallback(
                cdnSources.selfieSegmentation,
                'selfieSegmentation',
                (success) => {
                    selfieLoaded = success;
                    checkAllLoaded();
                }
            );

            loadScriptWithFallback(
                cdnSources.faceDetection,
                'faceDetection',
                (success) => {
                    faceLoaded = success;
                    checkAllLoaded();
                }
            );
        })();
    </script>

    <!-- Google Analytics 4 -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BHSENQTDSF"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-BHSENQTDSF', {
            'anonymize_ip': true,
            'cookie_flags': 'SameSite=None;Secure',
            'page_path': '/photo-editor.html'
        });

        // Track page view
        gtag('event', 'page_view', {
            page_title: 'Photo Editor',
            page_location: window.location.href,
            page_path: '/photo-editor.html'
        });
    </script>

    <!-- Microsoft Clarity -->
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "u9f5jiwh0y");
    </script>

    <!-- Structured Data for SEO -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Photo Editor - Passport Photo Maker",
      "applicationCategory": "UtilitiesApplication",
      "operatingSystem": "Any",
      "description": "Professional passport photo editor with AI face validation. Adjust, crop, and prepare perfect passport photos with guidelines.",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "featureList": [
        "Upload and crop passport photos",
        "AI-powered face validation",
        "Zoom and rotation controls",
        "US passport guideline overlay",
        "Grid with scale measurements",
        "High-quality 300 DPI output",
        "Privacy-focused (no server upload)",
        "Free forever"
      ],
      "browserRequirements": "Requires JavaScript. Requires HTML5.",
      "author": {
        "@type": "Organization",
        "name": "Photo Sheet Maker"
      }
    }
    </script>

    <style>
        :root {
            --primary-color: #007AFF;
            --primary-hover: #0051D5;
            --secondary-color: #5856D6;
            --accent-color: #FF2D55;
            --success-color: #34C759;
            --warning-color: #FF9500;
            --danger-color: #FF3B30;
            --text-primary: #1D1D1F;
            --text-secondary: #86868B;
            --background: #FFFFFF;
            --surface: #FFFFFF;
            --surface-secondary: #F5F5F7;
            --border: #D2D2D7;
            --shadow: rgba(0, 0, 0, 0.08);
            --shadow-md: rgba(0, 0, 0, 0.12);
            --shadow-lg: rgba(0, 0, 0, 0.16);
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 20px;
            --radius-xl: 24px;
            --spacing-xs: 8px;
            --spacing-sm: 12px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            --spacing-2xl: 48px;
            --spacing-3xl: 64px;
            --spacing-4xl: 96px;
            --font-system: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-smooth: all 0.6s cubic-bezier(0.16, 1, 0.3, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-system);
            background: var(--surface-secondary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Accessibility - Skip Link */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: var(--primary-color);
            color: white;
            padding: 8px 16px;
            text-decoration: none;
            border-radius: 0 0 4px 0;
            z-index: 100;
            font-weight: 600;
            transition: top 0.2s ease;
        }

        .skip-link:focus {
            top: 0;
            outline: 3px solid var(--warning-color);
            outline-offset: 2px;
        }

        /* Accessibility - Visually Hidden */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        /* Accessibility - Focus Indicators */
        *:focus-visible {
            outline: 3px solid var(--primary-color);
            outline-offset: 2px;
            border-radius: 4px;
        }

        button:focus-visible,
        a:focus-visible,
        input:focus-visible,
        select:focus-visible {
            outline: 3px solid var(--primary-color);
            outline-offset: 2px;
        }

        /* Accessibility - Reduced Motion */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
        }

        /* Accessibility - High Contrast Mode */
        @media (prefers-contrast: high) {
            :root {
                --primary-color: #0051D5;
                --text-primary: #000000;
                --text-secondary: #333333;
                --border: #000000;
            }

            .panel {
                border: 2px solid var(--border);
            }

            .btn {
                border: 2px solid currentColor;
            }
        }

        /* Language selector removed - using nav language selector instead */

        /* Main Content Section */
        .main-content {
            background: var(--background);
            padding: var(--spacing-4xl) 0;
            /* Add top padding on mobile to account for sticky nav */
            padding-top: calc(var(--spacing-xl) + env(safe-area-inset-top, 0px));
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: var(--spacing-xl) var(--spacing-lg);
        }

        /* Editor Layout */
        .editor-layout {
            display: grid;
            grid-template-columns: 320px 1fr 300px;
            gap: var(--spacing-lg);
            align-items: start;
            animation: fadeIn 0.6s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Panel/Card Styles - Matching index.html */
        .panel {
            background: var(--surface);
            border-radius: var(--radius-md);
            padding: var(--spacing-lg);
            box-shadow: 0 2px 16px var(--shadow), 0 0 0 1px rgba(0, 0, 0, 0.04);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(0, 0, 0, 0.04);
            position: relative;
            overflow: hidden;
        }

        .panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .panel:hover {
            box-shadow: 0 8px 32px var(--shadow-md), 0 0 0 1px rgba(0, 0, 0, 0.06);
            transform: translateY(-2px);
        }

        .panel:hover::before {
            opacity: 1;
        }

        .panel h3 {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: var(--spacing-md);
            color: var(--text-primary);
            letter-spacing: -0.3px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel h3::before {
            content: '';
            width: 4px;
            height: 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 2px;
        }

        /* Canvas Area */
        .canvas-panel {
            background: linear-gradient(135deg, #E5E5EA 0%, #D1D1D6 100%);
            padding: var(--spacing-xl);
            min-height: 600px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .canvas-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 10px,
                    rgba(255, 255, 255, 0.03) 10px,
                    rgba(255, 255, 255, 0.03) 20px
                );
            pointer-events: none;
        }

        .canvas-container {
            position: relative;
            background: #FFFFFF;
            box-shadow:
                0 10px 40px rgba(0,0,0,0.15),
                0 0 0 1px rgba(0,0,0,0.05),
                0 0 80px rgba(102, 126, 234, 0.1);
            border-radius: 12px;
            overflow: hidden;
            cursor: move;
            user-select: none;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1;
            /* Force proper compositing in Chrome */
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
            will-change: transform;
        }

        .canvas-container:hover {
            box-shadow:
                0 15px 50px rgba(0,0,0,0.2),
                0 0 0 1px rgba(0,0,0,0.08),
                0 0 100px rgba(102, 126, 234, 0.15);
        }

        #editCanvas {
            display: block;
            max-width: 100%;
            height: auto;
            /* Chrome-specific rendering improvements */
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        .overlay-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            max-width: 100%;
            height: auto;
            display: block;
            /* Ensure overlay doesn't affect underlying image brightness */
            mix-blend-mode: normal;
            isolation: isolate;
        }

        /* Guidelines Overlay */
        .guidelines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* Upload Area */
        .upload-area {
            border: 2px dashed var(--border);
            border-radius: var(--radius-md);
            padding: var(--spacing-xl);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(135deg, #FAFAFA 0%, #F5F5F7 100%);
            position: relative;
            overflow: hidden;
        }

        .upload-area::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300%;
            height: 300%;
            background: radial-gradient(circle, rgba(102, 126, 234, 0.03) 0%, transparent 70%);
            transform: translate(-50%, -50%) scale(0);
            transition: transform 0.6s ease;
        }

        .upload-area:hover::before {
            transform: translate(-50%, -50%) scale(1);
        }

        .upload-area:hover {
            border-color: var(--primary-color);
            background: linear-gradient(135deg, #FFFFFF 0%, #FAFAFA 100%);
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.1);
            transform: translateY(-2px);
        }

        .upload-area.dragover {
            border-color: var(--primary-color);
            background: rgba(102, 126, 234, 0.05);
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 12px;
            display: inline-block;
            animation: bounce 2s ease-in-out infinite;
            filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.1));
        }

        @keyframes bounceExcited {
            0%, 100% {
                transform: translateY(0) scale(1);
            }
            50% {
                transform: translateY(-15px) scale(1.1);
            }
        }

        .upload-area:hover .upload-icon {
            animation: bounceExcited 0.6s ease-in-out infinite;
        }

        .upload-text {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
            position: relative;
            z-index: 1;
        }

        .upload-hint {
            font-size: 14px;
            color: var(--text-secondary);
            position: relative;
            z-index: 1;
        }

        #fileInput {
            display: none;
        }

        /* Controls */
        .control-group {
            margin-bottom: var(--spacing-lg);
        }

        .control-label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(90deg, #E5E5EA 0%, #D1D1D6 100%);
            outline: none;
            transition: all 0.2s ease;
        }

        .slider:hover {
            background: linear-gradient(90deg, #D1D1D6 0%, #C7C7CC 100%);
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary-color) 0%, #0051D5 100%);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(0, 122, 255, 0.3);
            border: 2px solid white;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.5);
        }

        .slider::-webkit-slider-thumb:active {
            transform: scale(1.1);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary-color) 0%, #0051D5 100%);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 8px rgba(0, 122, 255, 0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .slider::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.5);
        }

        .slider-value {
            min-width: 45px;
            text-align: right;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .btn {
            width: 100%;
            padding: 14px 20px;
            border: none;
            border-radius: var(--radius-md);
            font-size: 15px;
            font-weight: 600;
            font-family: var(--font-system);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            margin-bottom: 12px;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:active::before {
            width: 300px;
            height: 300px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary-color) 0%, #0051D5 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3);
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #0051D5 0%, #003DA5 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 122, 255, 0.4);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(135deg, var(--surface) 0%, #F5F5F7 100%);
            color: var(--text-primary);
            border: 2px solid var(--border);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .btn-secondary:hover {
            border-color: var(--primary-color);
            background: linear-gradient(135deg, #FFFFFF 0%, #FAFAFA 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.15);
        }

        .btn-secondary:active {
            transform: translateY(0);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success-color) 0%, #28a745 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(52, 199, 89, 0.3);
        }

        .btn-success:hover {
            background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(52, 199, 89, 0.4);
        }

        .btn-success:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        /* Guidelines Toggle */
        .toggle-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .toggle-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: linear-gradient(135deg, #F9F9F9 0%, #F5F5F7 100%);
            border-radius: 10px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .toggle-item:hover {
            background: linear-gradient(135deg, #FFFFFF 0%, #F9F9F9 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            transform: translateX(2px);
        }

        .toggle-label {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
        }

        .toggle-switch {
            position: relative;
            width: 48px;
            height: 28px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            border-radius: 28px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            border-radius: 50%;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        input:checked + .toggle-slider {
            background: linear-gradient(135deg, var(--primary-color) 0%, #0051D5 100%);
            box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.1), inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(20px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        input:focus + .toggle-slider {
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.2);
        }

        /* Instructions */
        .instructions {
            background: linear-gradient(135deg, #E3F2FD 0%, #BBDEFB 100%);
            padding: var(--spacing-md);
            border-radius: 10px;
            font-size: 13px;
            line-height: 1.6;
            color: #0066CC;
            border: 1px solid rgba(0, 122, 255, 0.2);
            box-shadow: 0 2px 8px rgba(0, 122, 255, 0.1);
        }

        .instructions strong {
            display: block;
            margin-bottom: 8px;
            color: var(--primary-color);
            font-size: 14px;
        }

        .instructions ul {
            margin-left: 18px;
            margin-top: 8px;
        }

        .instructions li {
            margin-bottom: 4px;
            position: relative;
            padding-left: 4px;
        }

        .instructions li::marker {
            color: var(--primary-color);
        }

        /* Collapsible Instructions */
        .instructions-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
            margin-bottom: 8px;
            padding: 4px 0;
            transition: var(--transition);
        }

        .instructions-header:hover {
            opacity: 0.8;
        }

        .instructions-header strong {
            margin-bottom: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .collapse-icon {
            font-size: 18px;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: var(--primary-color);
            font-weight: bold;
        }

        .instructions.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .instructions-content {
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
            opacity: 1;
        }

        .instructions.collapsed .instructions-content {
            max-height: 0;
            opacity: 0;
        }

        /* Info Badge */
        .info-badge {
            background: linear-gradient(135deg, #FFF9E6 0%, #FFF3CD 100%);
            border: 1px solid #FFE69C;
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            font-size: 13px;
            color: #856404;
            margin-bottom: var(--spacing-md);
            box-shadow: 0 2px 12px rgba(255, 183, 77, 0.15);
            position: relative;
            overflow: hidden;
        }

        .info-badge::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, #FFA500, #FF9500);
        }

        .info-badge strong {
            display: block;
            margin-bottom: 6px;
            font-size: 14px;
            color: #664d03;
            padding-left: 12px;
        }

        .info-badge:last-child {
            margin-bottom: 0;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .editor-layout {
                grid-template-columns: 1fr;
                gap: var(--spacing-lg);
            }

            .left-panel, .right-panel {
                max-width: 600px;
                margin: 0 auto;
            }
        }

        @media (max-width: 768px) {
            .main-content {
                padding: var(--spacing-lg) 0;
                /* Reduce top padding on mobile since sticky nav is thinner */
                padding-top: var(--spacing-md);
            }

            .container {
                padding: var(--spacing-lg) var(--spacing-md);
            }

            .panel {
                padding: var(--spacing-md);
            }

            .panel h3 {
                font-size: 18px;
            }

            .editor-layout {
                gap: var(--spacing-md);
            }

            /* Canvas panel adjustments for mobile */
            .canvas-panel {
                min-height: 400px;
                padding: var(--spacing-lg);
            }

            /* Make canvas responsive */
            #editCanvas,
            #overlayCanvas {
                max-width: 100%;
                height: auto !important;
            }

            /* Control sliders - make touch-friendly */
            .slider {
                height: 8px;
            }

            .slider::-webkit-slider-thumb {
                width: 24px;
                height: 24px;
            }

            .slider::-moz-range-thumb {
                width: 24px;
                height: 24px;
            }

            /* Buttons - make larger for touch */
            .btn {
                padding: 16px 20px;
                font-size: 16px;
            }

            /* Info badges - more compact on mobile */
            .info-badge {
                font-size: 12px;
                padding: var(--spacing-sm);
            }

            /* Instructions - collapsed by default on mobile */
            .instructions {
                font-size: 12px;
            }

            /* Validation results - more readable on mobile */
            #validationResults {
                font-size: 13px;
            }

            /* Adjust keyboard shortcuts display */
            kbd {
                font-size: 10px;
                padding: 2px 4px;
            }
        }

        @media (max-width: 480px) {
            /* Extra small mobile devices */
            .main-content {
                padding: var(--spacing-sm) 0;
            }

            .container {
                padding: var(--spacing-md) var(--spacing-sm);
            }

            .panel {
                padding: var(--spacing-sm);
                border-radius: var(--radius-sm);
            }

            .panel h3 {
                font-size: 16px;
                margin-bottom: var(--spacing-sm);
            }

            /* Canvas - even more compact */
            .canvas-panel {
                min-height: 300px;
                padding: var(--spacing-md);
            }

            /* Controls - stack better */
            .control-group {
                margin-bottom: var(--spacing-md);
            }

            .control-label {
                font-size: 13px;
            }

            /* Buttons - full width on very small screens */
            .btn {
                padding: 14px 16px;
                font-size: 15px;
            }

            /* Toggle items - more compact */
            .toggle-item {
                padding: 10px 12px;
            }

            .toggle-label {
                font-size: 13px;
            }

            /* Info badges and instructions */
            .info-badge,
            .instructions {
                font-size: 11px;
                padding: 10px;
            }

            /* Make upload area more compact */
            .upload-area {
                min-height: 180px;
                padding: var(--spacing-md);
            }

            .upload-icon {
                font-size: 36px;
                margin-bottom: var(--spacing-sm);
            }

            .upload-text {
                font-size: 16px;
            }

            .upload-hint {
                font-size: 12px;
            }
        }

        /* Keyboard Shortcut Display */
        kbd {
            display: inline-block;
            padding: 2px 6px;
            font-size: 11px;
            font-family: var(--font-system);
            font-weight: 600;
            color: var(--text-primary);
            background: linear-gradient(135deg, #FFFFFF 0%, #F5F5F7 100%);
            border: 1px solid var(--border);
            border-radius: 4px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1), inset 0 -1px 0 rgba(0, 0, 0, 0.1);
            white-space: nowrap;
        }

        /* Crop Rectangle Styles */
        #cropRect {
            position: absolute;
            border: 3px solid rgba(255, 45, 85, 0.8);
            background: rgba(255, 45, 85, 0.1);
            cursor: move;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
            pointer-events: none;
        }

        #cropRect.active {
            pointer-events: all;
        }

        .crop-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: white;
            border: 2px solid var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
            z-index: 10;
        }

        .crop-handle.nw { top: -6px; left: -6px; cursor: nwse-resize; }
        .crop-handle.ne { top: -6px; right: -6px; cursor: nesw-resize; }
        .crop-handle.sw { bottom: -6px; left: -6px; cursor: nesw-resize; }
        .crop-handle.se { bottom: -6px; right: -6px; cursor: nwse-resize; }

        /* Loading State */
        .loading {
            text-align: center;
            padding: var(--spacing-xl);
        }

        .spinner {
            border: 4px solid rgba(0, 122, 255, 0.1);
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s cubic-bezier(0.5, 0, 0.5, 1) infinite;
            margin: 0 auto 16px;
            position: relative;
        }

        .spinner::after {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            border-radius: 50%;
            border: 4px solid transparent;
            border-top-color: rgba(0, 122, 255, 0.3);
            animation: spin 2s cubic-bezier(0.5, 0, 0.5, 1) infinite reverse;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .processing-text {
            color: var(--text-secondary);
            font-size: 14px;
        }

        /* Footer Styles */
        .footer {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: var(--radius-xl);
            padding: var(--spacing-2xl);
            margin-top: var(--spacing-xl);
            box-shadow: 0 8px 32px var(--shadow-lg);
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        /* Footer styles moved to css/common.css */

        /* Validation Results Enhancements */
        #validationResults {
            animation: slideIn 0.4s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Photo Info Badge Enhancement */
        #photoInfo {
            animation: fadeIn 0.5s ease-out 0.3s both;
        }

        /* Add subtle glow effect to active canvas */
        .canvas-container:active {
            box-shadow:
                0 15px 50px rgba(0,0,0,0.25),
                0 0 0 1px rgba(0,0,0,0.1),
                0 0 120px rgba(102, 126, 234, 0.2);
        }

        /* Touch Gesture Hints */
        .touch-hints {
            display: none;
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 12px 20px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 500;
            z-index: 100;
            animation: fadeInUp 0.5s ease-out;
            pointer-events: none;
            text-align: center;
            line-height: 1.4;
        }

        @media (hover: none) and (pointer: coarse) {
            .touch-hints {
                display: block;
            }
        }

        .touch-hint-icon {
            font-size: 20px;
            margin-bottom: 4px;
        }
    </style>

    <!-- UX Component Styles -->
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/components.css">
    <link rel="stylesheet" href="css/ux-components.css">
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <!-- NAVIGATION HEADER -->
    <nav class="main-nav" role="navigation" aria-label="Main navigation">
        <div class="nav-container">
            <!-- Logo -->
            <a href="index.html" class="nav-logo" aria-label="Home">
                üì∏ Photo Sheet Maker
            </a>

            <!-- Navigation Links -->
            <div class="nav-links">
                <a href="index.html" class="nav-link">
                    <span data-i18n="photoMaker">Photo Maker</span>
                </a>
                <a href="photo-editor.html" class="nav-link featured active" aria-current="page">
                    ‚úÇÔ∏è <span data-i18n="photoEditor">Photo Editor</span>
                </a>
                <a href="faq.html" class="nav-link">
                    <span data-i18n="help">Help</span>
                </a>
            </div>

            <!-- Language Selector -->
            <select id="languageSelect" class="nav-language" aria-label="Select language">
                <option value="en">üá∫üá∏ English</option>
                <option value="es">üá™üá∏ Espa√±ol</option>
                <option value="fr">üá´üá∑ Fran√ßais</option>
                <option value="de">üá©üá™ Deutsch</option>
                <option value="pt">üáµüáπ Portugu√™s</option>
                <option value="it">üáÆüáπ Italiano</option>
                <option value="ja">üáØüáµ Êó•Êú¨Ë™û</option>
                <option value="ko">üá∞üá∑ ÌïúÍµ≠Ïñ¥</option>
                <option value="zh">üá®üá≥ ‰∏≠Êñá</option>
                <option value="ar">üá∏üá¶ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</option>
                <option value="hi">üáÆüá≥ ‡§π‡§ø‡§®‡•ç‡§¶‡•Ä</option>
                <option value="ru">üá∑üá∫ –†—É—Å—Å–∫–∏–π</option>
            </select>

            <!-- Mobile Menu Toggle -->
            <button class="mobile-menu-toggle" aria-label="Toggle mobile menu" aria-expanded="false">
                ‚ò∞
            </button>
        </div>
    </nav>

    <!-- Main Content -->
    <div class="main-content">
    <div class="container">
        <main id="main-content" class="editor-layout" role="main">
            <!-- Left Panel: Upload & Guidelines -->
            <div class="left-panel">
                <div class="panel">
                    <h3 data-i18n="upload_title">1. Upload Photo</h3>
                    <!-- Upload UI will be dynamically generated by photoHandler.js -->
                    <div id="uploadContainer"></div>
                </div>

                <div class="panel" style="margin-top: 20px;">
                    <h3 data-i18n="guidelines_title">Guidelines</h3>
                    <div class="toggle-group">
                        <div class="toggle-item">
                            <span class="toggle-label" id="faceGuideLabel" data-i18n="face_outline">Face Outline</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="toggleFaceGuide" checked
                                       role="switch" aria-checked="true" aria-labelledby="faceGuideLabel">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div class="toggle-item">
                            <span class="toggle-label" id="gridLabel" data-i18n="grid_scale">Grid with Scale</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="toggleGrid"
                                       role="switch" aria-checked="false" aria-labelledby="gridLabel">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>

                    <div id="instructionsPanel" class="instructions" style="margin-top: 20px;">
                        <div class="instructions-header" onclick="toggleInstructions()" role="button" tabindex="0" aria-expanded="true" aria-controls="instructionsContent">
                            <strong>
                                <span>üìã</span>
                                <span>US Passport Requirements</span>
                            </strong>
                            <span class="collapse-icon" aria-hidden="true">‚ñº</span>
                        </div>
                        <div id="instructionsContent" class="instructions-content">
                            <ul>
                                <li>Head height: 1" to 1-3/8"</li>
                                <li>Face centered horizontally</li>
                                <li>Neutral expression</li>
                                <li>White/off-white background</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Center Column: Canvas + Export -->
            <div>
                <!-- Canvas Panel -->
                <div class="canvas-panel panel" id="canvasPanel">
                    <div id="uploadPrompt">
                        <div style="text-align: center; color: var(--text-secondary);">
                            <div style="font-size: 64px; margin-bottom: 16px;">üì∏</div>
                            <h3 style="font-size: 20px; margin-bottom: 8px; color: var(--text-primary);">Upload a photo to get started</h3>
                            <p>Select a photo from the left panel</p>
                        </div>
                    </div>
                    <div id="canvasContainer" class="canvas-container" style="display: none;"
                         aria-label="Passport photo editing canvas">
                        <canvas id="editCanvas" aria-label="Main editing canvas"></canvas>
                        <canvas id="overlayCanvas" class="overlay-canvas" aria-hidden="true"></canvas>
                        <!-- Touch Gesture Hints for Mobile -->
                        <div class="touch-hints" aria-live="polite">
                            <div class="touch-hint-icon">üëÜ</div>
                            Pinch to zoom ‚Ä¢ Drag to move
                        </div>
                    </div>
                    <div id="photoInfo" style="display: none; text-align: center; margin-top: 16px; padding: 12px; background: rgba(0, 122, 255, 0.05); border-radius: 8px; font-size: 13px; color: var(--text-secondary);">
                        <strong style="color: var(--text-primary);">Photo Specifications</strong><br>
                        <span style="display: inline-block; margin-top: 6px;">
                            <strong>Size:</strong> 2√ó2 inches (51√ó51 mm) ‚Ä¢
                            <strong>Resolution:</strong> 600√ó600 pixels @ 300 DPI
                        </span>
                    </div>
                </div>

                <!-- Export Panel - Separate panel below canvas -->
                <div class="panel" style="margin-top: 20px;">
                    <h3>Export</h3>
                    <button class="btn btn-success" id="exportBtn" disabled
                            aria-label="Use this photo to create a photo sheet - returns to the main photo maker page">
                        ‚úì Create Photo Sheet
                    </button>
                    <button class="btn btn-secondary" id="downloadBtn" disabled
                            aria-label="Download edited photo as JPEG file to your device">
                        ‚¨á Download to Device
                    </button>
                </div>
            </div>

            <!-- Right Panel: Controls -->
            <div class="right-panel">
                <div class="panel">
                    <h3>2. Adjust Photo</h3>

                    <div class="info-badge">
                        <strong>üí° Quick Tips</strong>
                        Drag to pan ‚Ä¢ Scroll to zoom ‚Ä¢ Align face with guides
                    </div>

                    <div class="control-group">
                        <label class="control-label" for="zoomSlider">Zoom</label>
                        <div class="slider-container">
                            <input type="range" id="zoomSlider" class="slider"
                                   min="0.1" max="3" step="0.01" value="1"
                                   aria-label="Zoom level" aria-valuemin="0.1" aria-valuemax="3" aria-valuenow="1" aria-valuetext="100%">
                            <span class="slider-value" id="zoomValue" aria-live="polite">100%</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label class="control-label" for="rotationSlider">Rotation</label>
                        <div class="slider-container">
                            <input type="range" id="rotationSlider" class="slider"
                                   min="-45" max="45" step="0.1" value="0"
                                   aria-label="Rotation angle" aria-valuemin="-45" aria-valuemax="45" aria-valuenow="0" aria-valuetext="0 degrees">
                            <span class="slider-value" id="rotationValue" aria-live="polite">0¬∞</span>
                        </div>
                    </div>

                    <button class="btn btn-secondary" id="resetBtn" disabled
                            aria-label="Reset photo position, zoom, and rotation to defaults">
                        ‚Üª Reset Position
                    </button>

                    <!-- Keyboard Shortcuts Info -->
                    <div class="info-badge" style="margin-top: 16px; background: linear-gradient(135deg, #E3F2FD 0%, #BBDEFB 100%); border-color: rgba(0, 122, 255, 0.2);">
                        <strong>‚å®Ô∏è Keyboard Shortcuts</strong>
                        <div style="font-size: 12px; margin-top: 8px; line-height: 1.6;">
                            ‚Ä¢ <kbd>+</kbd> / <kbd>-</kbd> Zoom in/out<br>
                            ‚Ä¢ <kbd>‚Üê</kbd> <kbd>‚Üí</kbd> Rotate left/right<br>
                            ‚Ä¢ <kbd>R</kbd> Reset position<br>
                            ‚Ä¢ <kbd>C</kbd> Toggle crop mode<br>
                            ‚Ä¢ <kbd>V</kbd> Validate face<br>
                            ‚Ä¢ <kbd>Esc</kbd> Cancel crop
                        </div>
                    </div>
                </div>

                <!-- Crop Tool Section -->
                <div class="panel" style="margin-top: 20px;">
                    <h3>2b. Crop Tool</h3>

                    <button class="btn btn-primary" id="cropModeBtn" disabled
                            aria-label="Toggle crop mode to define crop area">
                        ‚úÇÔ∏è Enable Crop Mode
                    </button>

                    <div id="cropInstructions" style="display: none; margin-top: 16px; padding: 12px; background: rgba(0, 122, 255, 0.05); border-radius: 8px; border: 1px solid rgba(0, 122, 255, 0.2);">
                        <strong style="color: var(--primary-color); font-size: 14px;">üìê Crop Mode Active</strong>
                        <p style="font-size: 13px; margin-top: 8px; color: var(--text-secondary);">
                            Click and drag on the image to define the crop area. The red rectangle shows what will be kept.
                        </p>
                        <p style="font-size: 12px; margin-top: 6px; color: var(--text-secondary); font-style: italic;">
                            Note: Pan and zoom are disabled during crop mode.
                        </p>
                    </div>

                    <div id="cropControls" style="display: none; margin-top: 16px;">
                        <button class="btn btn-success" id="applyCropBtn"
                                aria-label="Apply the crop and keep only the selected area">
                            ‚úì Apply Crop
                        </button>
                        <button class="btn btn-secondary" id="cancelCropBtn"
                                aria-label="Cancel crop mode and return to normal editing">
                            ‚úï Cancel
                        </button>
                    </div>
                </div>

                <!-- Background Removal Section - Hidden for future improvements -->
                <!--
                <div class="panel" style="margin-top: 20px;">
                    <h3>3. Background</h3>

                    <button class="btn btn-primary" id="removeBackgroundBtn" disabled>
                        üé® Remove Background
                    </button>

                    <div class="control-group">
                        <label class="control-label">Background Color</label>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                            <button class="bg-color-btn" data-color="#FFFFFF"
                                    style="background: white; border: 2px solid #ddd; height: 40px; border-radius: 8px; cursor: pointer;">
                                White
                            </button>
                            <button class="bg-color-btn" data-color="#F5F5F0"
                                    style="background: #F5F5F0; border: 2px solid #ddd; height: 40px; border-radius: 8px; cursor: pointer;">
                                Off-White
                            </button>
                            <button class="bg-color-btn" data-color="#E8E8E8"
                                    style="background: #E8E8E8; border: 2px solid #ddd; height: 40px; border-radius: 8px; cursor: pointer;">
                                Light Gray
                            </button>
                        </div>
                    </div>

                    <div id="loadingIndicator" class="loading" style="display: none;">
                        <div class="spinner"></div>
                        <div class="processing-text">Processing...</div>
                    </div>
                </div>
                -->

                <div class="panel" style="margin-top: 20px;">
                    <h3>3. Face Validation</h3>

                    <button class="btn btn-primary" id="validateFaceBtn" disabled
                            aria-label="Check if face position meets passport photo requirements">
                        üë§ Check Face Position
                    </button>

                    <div id="validationResults" style="display: none; margin-top: 16px; padding: 16px; border-radius: 8px; font-size: 14px; line-height: 1.6;"
                         role="status" aria-live="polite">
                        <!-- Results will be inserted here -->
                    </div>
                </div>
            </div>
        </main>
    </div>
    </div>

    <!-- Footer Container - Loaded from components/footer.html -->
    <div id="footer-container"></div>

    <!-- Load translations from modular structure -->
    <script type="module" src="translations/index.js"></script>

    <script>
        // Current year will be set by loadFooter() in common.js

        // Canvas size for 2x2 inch photo at 300 DPI
        const CANVAS_SIZE = 600;

        // State variables
        let originalImage = null;
        let currentImage = null;
        let scale = 1;
        let rotation = 0;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let backgroundRemoved = false;

        // Crop mode state variables
        let cropMode = false;
        let cropRect = null;
        let cropStartX = 0;
        let cropStartY = 0;
        let isCropping = false;

        // DOM elements
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const uploadPrompt = document.getElementById('uploadPrompt');
        const canvasContainer = document.getElementById('canvasContainer');
        const editCanvas = document.getElementById('editCanvas');
        const overlayCanvas = document.getElementById('overlayCanvas');
        const ctx = editCanvas.getContext('2d', { alpha: true });
        const overlayCtx = overlayCanvas.getContext('2d', { alpha: true });

        const zoomSlider = document.getElementById('zoomSlider');
        const zoomValue = document.getElementById('zoomValue');
        const rotationSlider = document.getElementById('rotationSlider');
        const rotationValue = document.getElementById('rotationValue');
        const resetBtn = document.getElementById('resetBtn');
        const removeBackgroundBtn = document.getElementById('removeBackgroundBtn');
        const validateFaceBtn = document.getElementById('validateFaceBtn');
        const validationResults = document.getElementById('validationResults');
        const exportBtn = document.getElementById('exportBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const photoInfo = document.getElementById('photoInfo');

        const toggleFaceGuide = document.getElementById('toggleFaceGuide');
        const toggleGrid = document.getElementById('toggleGrid');

        // Crop tool elements
        const cropModeBtn = document.getElementById('cropModeBtn');
        const cropInstructions = document.getElementById('cropInstructions');
        const cropControls = document.getElementById('cropControls');
        const applyCropBtn = document.getElementById('applyCropBtn');
        const cancelCropBtn = document.getElementById('cancelCropBtn');

        // Initialize canvas
        editCanvas.width = CANVAS_SIZE;
        editCanvas.height = CANVAS_SIZE;
        overlayCanvas.width = CANVAS_SIZE;
        overlayCanvas.height = CANVAS_SIZE;

        // ======================================
        // Photo Upload - Now handled by photoHandler module
        // See: js/photoHandler.js and js/photoHandler-editor.js
        // Integration script at bottom of file
        // ======================================

        /**
         * Toggle instructions panel collapse/expand
         */
        function toggleInstructions() {
            const panel = document.getElementById('instructionsPanel');
            const header = panel.querySelector('.instructions-header');
            const content = document.getElementById('instructionsContent');

            const isCollapsed = panel.classList.contains('collapsed');

            if (isCollapsed) {
                // Expand
                panel.classList.remove('collapsed');
                header.setAttribute('aria-expanded', 'true');
            } else {
                // Collapse
                panel.classList.add('collapsed');
                header.setAttribute('aria-expanded', 'false');
            }

            // Track toggle action
            if (typeof gtag !== 'undefined') {
                gtag('event', 'instructions_toggled', {
                    'event_category': 'Photo Editor',
                    'event_label': isCollapsed ? 'Expanded' : 'Collapsed'
                });
            }
        }

        // Keyboard accessibility for instructions toggle
        document.addEventListener('DOMContentLoaded', () => {
            const instructionsHeader = document.querySelector('.instructions-header');
            if (instructionsHeader) {
                instructionsHeader.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        toggleInstructions();
                    }
                });
            }
        });

        // ======================================
        // Photo Upload - Now handled by photoHandler module
        // See: js/photoHandler.js and js/photoHandler-editor.js
        // Integration script at bottom of file
        // ======================================


        function showCanvas() {
            uploadPrompt.style.display = 'none';
            canvasContainer.style.display = 'block';
            photoInfo.style.display = 'block';
        }

        function enableControls() {
            resetBtn.disabled = false;
            cropModeBtn.disabled = false;
            // removeBackgroundBtn.disabled = false; // Commented out - UI removed

            // Only enable face validation if MediaPipe is available
            if (window.mediaPipeAvailable !== false) {
                validateFaceBtn.disabled = false;
            } else {
                validateFaceBtn.disabled = true;
                validateFaceBtn.title = 'Face validation unavailable (CDN blocked)';
                validateFaceBtn.style.opacity = '0.5';
            }

            exportBtn.disabled = false;
            downloadBtn.disabled = false;
        }

        function resetTransform() {
            // Calculate initial scale to fit image in canvas
            if (currentImage) {
                // Calculate scale to fit image within canvas while maintaining aspect ratio
                const scaleX = CANVAS_SIZE / currentImage.width;
                const scaleY = CANVAS_SIZE / currentImage.height;
                const autoScale = Math.min(scaleX, scaleY, 1); // Don't scale up, only down if needed

                scale = autoScale;
            } else {
                scale = 1;
            }

            rotation = 0;
            offsetX = 0;
            offsetY = 0;
            zoomSlider.value = scale;
            rotationSlider.value = 0;
            updateSliderValues();

            // Also reset background removal if applied
            if (backgroundRemoved) {
                currentImage = originalImage;
                backgroundRemoved = false;
                // Update button UI only if button exists (UI may be commented out)
                if (removeBackgroundBtn) {
                    removeBackgroundBtn.textContent = 'üé® Remove Background';
                    removeBackgroundBtn.style.background = '';
                    removeBackgroundBtn.disabled = false;
                }
            }
        }

        // Render canvas
        function render() {
            if (!currentImage) return;

            // Clear canvas
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Save context
            ctx.save();

            // Move to center
            ctx.translate(CANVAS_SIZE / 2, CANVAS_SIZE / 2);

            // Apply rotation
            ctx.rotate((rotation * Math.PI) / 180);

            // Apply scale and offset
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            // Draw image centered
            ctx.drawImage(
                currentImage,
                -currentImage.width / 2,
                -currentImage.height / 2,
                currentImage.width,
                currentImage.height
            );

            // Restore context
            ctx.restore();

            // Draw overlay
            drawOverlay();
        }

        // Draw guidelines overlay
        function drawOverlay() {
            overlayCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Face guide (oval) - US passport spec:
            // Photo: 2x2 inches
            // Head: 1 to 1.4 inches (50% to 70% of photo) - we'll show 60% (1.2 inches) as ideal
            if (toggleFaceGuide.checked) {
                overlayCtx.strokeStyle = 'rgba(0, 122, 255, 0.45)';
                overlayCtx.lineWidth = 3;
                overlayCtx.setLineDash([8, 6]);

                const centerX = CANVAS_SIZE / 2;

                // Head height: 60% of photo (1.2" ideal)
                const headHeightPercent = 0.60;
                const radiusY = CANVAS_SIZE * (headHeightPercent / 2); // 30% radius = 60% height

                // Eyes are typically 1/3 down from crown of head
                // If eyes should be at ~37.5% from top (middle of 31-44% range)
                // And eyes are 1/3 down from crown, then crown is at:
                const eyePositionPercent = 0.375;
                const eyesToCrownPercent = headHeightPercent / 3; // ~20%
                const crownPercent = eyePositionPercent - eyesToCrownPercent; // ~17.5%

                // Face center is halfway between crown and chin
                const centerY = CANVAS_SIZE * (crownPercent + (headHeightPercent / 2)); // ~47.5%

                // Face width: typically 70-75% of face height for realistic oval
                const radiusX = radiusY * 0.72; // More realistic face proportions

                overlayCtx.beginPath();
                overlayCtx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
                overlayCtx.stroke();

                // Add reference markers at top and bottom of face guide
                overlayCtx.setLineDash([]);
                overlayCtx.strokeStyle = 'rgba(0, 122, 255, 0.3)';
                overlayCtx.lineWidth = 1;

                // Top of head marker (crown)
                const topY = centerY - radiusY;
                overlayCtx.beginPath();
                overlayCtx.moveTo(centerX - 30, topY);
                overlayCtx.lineTo(centerX + 30, topY);
                overlayCtx.stroke();

                // Add label for crown
                overlayCtx.fillStyle = 'rgba(0, 122, 255, 0.6)';
                overlayCtx.font = '11px -apple-system, sans-serif';
                overlayCtx.fillText('Crown', centerX + 35, topY + 4);

                // Bottom of chin marker
                const bottomY = centerY + radiusY;
                overlayCtx.beginPath();
                overlayCtx.moveTo(centerX - 30, bottomY);
                overlayCtx.lineTo(centerX + 30, bottomY);
                overlayCtx.stroke();

                // Add label for chin
                overlayCtx.fillText('Chin', centerX + 35, bottomY + 4);
            }

            // Grid with scale markings
            if (toggleGrid.checked) {
                overlayCtx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
                overlayCtx.lineWidth = 1;
                overlayCtx.setLineDash([4, 4]);

                // Center cross (most important)
                overlayCtx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                overlayCtx.lineWidth = 2;

                // Vertical center
                overlayCtx.beginPath();
                overlayCtx.moveTo(CANVAS_SIZE / 2, 0);
                overlayCtx.lineTo(CANVAS_SIZE / 2, CANVAS_SIZE);
                overlayCtx.stroke();

                // Horizontal center
                overlayCtx.beginPath();
                overlayCtx.moveTo(0, CANVAS_SIZE / 2);
                overlayCtx.lineTo(CANVAS_SIZE, CANVAS_SIZE / 2);
                overlayCtx.stroke();

                // Thirds grid (lighter)
                overlayCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                overlayCtx.lineWidth = 1;

                // Vertical thirds
                for (let i = 1; i < 3; i++) {
                    const x = (CANVAS_SIZE / 3) * i;
                    overlayCtx.beginPath();
                    overlayCtx.moveTo(x, 0);
                    overlayCtx.lineTo(x, CANVAS_SIZE);
                    overlayCtx.stroke();
                }

                // Horizontal thirds
                for (let i = 1; i < 3; i++) {
                    const y = (CANVAS_SIZE / 3) * i;
                    overlayCtx.beginPath();
                    overlayCtx.moveTo(0, y);
                    overlayCtx.lineTo(CANVAS_SIZE, y);
                    overlayCtx.stroke();
                }

                overlayCtx.setLineDash([]);

                // Helper function to draw text with background for better readability
                function drawScaleText(text, x, y) {
                    overlayCtx.font = 'bold 13px -apple-system, sans-serif';
                    const metrics = overlayCtx.measureText(text);
                    const padding = 3;

                    // Draw semi-transparent background
                    overlayCtx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    overlayCtx.fillRect(
                        x - padding,
                        y - 10 - padding,
                        metrics.width + padding * 2,
                        14 + padding * 2
                    );

                    // Draw white text with shadow for extra contrast
                    overlayCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    overlayCtx.shadowBlur = 3;
                    overlayCtx.shadowOffsetX = 1;
                    overlayCtx.shadowOffsetY = 1;
                    overlayCtx.fillStyle = '#FFFFFF';
                    overlayCtx.fillText(text, x, y);

                    // Reset shadow
                    overlayCtx.shadowColor = 'transparent';
                    overlayCtx.shadowBlur = 0;
                    overlayCtx.shadowOffsetX = 0;
                    overlayCtx.shadowOffsetY = 0;
                }

                // Add scale markings on all edges
                overlayCtx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                overlayCtx.lineWidth = 2;

                // Scale: 2 inches = 600px, so each 0.5" = 150px, each 0.25" = 75px
                const quarterInch = CANVAS_SIZE / 8; // 75px = 0.25"
                const halfInch = CANVAS_SIZE / 4;     // 150px = 0.5"

                // Top edge - horizontal scale
                for (let i = 0; i <= 8; i++) {
                    const x = i * quarterInch;
                    const isMajor = i % 2 === 0; // Every half inch
                    const tickHeight = isMajor ? 16 : 8;

                    overlayCtx.beginPath();
                    overlayCtx.moveTo(x, 0);
                    overlayCtx.lineTo(x, tickHeight);
                    overlayCtx.stroke();

                    if (isMajor && i > 0 && i < 8) {
                        drawScaleText((i * 0.25).toFixed(2) + '"', x - 14, tickHeight + 16);
                    }
                }

                // Bottom edge - horizontal scale
                for (let i = 0; i <= 8; i++) {
                    const x = i * quarterInch;
                    const isMajor = i % 2 === 0;
                    const tickHeight = isMajor ? 16 : 8;

                    overlayCtx.beginPath();
                    overlayCtx.moveTo(x, CANVAS_SIZE);
                    overlayCtx.lineTo(x, CANVAS_SIZE - tickHeight);
                    overlayCtx.stroke();

                    if (isMajor && i > 0 && i < 8) {
                        drawScaleText((i * 0.25).toFixed(2) + '"', x - 14, CANVAS_SIZE - tickHeight - 6);
                    }
                }

                // Left edge - vertical scale
                for (let i = 0; i <= 8; i++) {
                    const y = i * quarterInch;
                    const isMajor = i % 2 === 0;
                    const tickWidth = isMajor ? 16 : 8;

                    overlayCtx.beginPath();
                    overlayCtx.moveTo(0, y);
                    overlayCtx.lineTo(tickWidth, y);
                    overlayCtx.stroke();

                    if (isMajor && i > 0 && i < 8) {
                        overlayCtx.save();
                        drawScaleText((i * 0.25).toFixed(2) + '"', tickWidth + 4, y + 4);
                        overlayCtx.restore();
                    }
                }

                // Right edge - vertical scale
                for (let i = 0; i <= 8; i++) {
                    const y = i * quarterInch;
                    const isMajor = i % 2 === 0;
                    const tickWidth = isMajor ? 16 : 8;

                    overlayCtx.beginPath();
                    overlayCtx.moveTo(CANVAS_SIZE, y);
                    overlayCtx.lineTo(CANVAS_SIZE - tickWidth, y);
                    overlayCtx.stroke();

                    if (isMajor && i > 0 && i < 8) {
                        overlayCtx.save();
                        drawScaleText((i * 0.25).toFixed(2) + '"', CANVAS_SIZE - tickWidth - 32, y + 4);
                        overlayCtx.restore();
                    }
                }
            }
        }

        // Zoom control
        zoomSlider.addEventListener('input', (e) => {
            scale = parseFloat(e.target.value);
            updateSliderValues();
            render();
        });

        // Track zoom changes (throttled)
        let zoomTrackTimeout;
        zoomSlider.addEventListener('change', (e) => {
            clearTimeout(zoomTrackTimeout);
            zoomTrackTimeout = setTimeout(() => {
                if (typeof gtag !== 'undefined') {
                    gtag('event', 'zoom_adjusted', {
                        'event_category': 'Photo Editor',
                        'event_label': 'Zoom Control',
                        'value': Math.round(scale * 100)
                    });
                }
            }, 500);
        });

        // Prevent zoom slider from stealing focus
        zoomSlider.addEventListener('focus', () => {
            if (isDragging) {
                zoomSlider.blur();
            }
        });

        // Rotation control
        rotationSlider.addEventListener('input', (e) => {
            rotation = parseFloat(e.target.value);
            updateSliderValues();
            render();
        });

        // Track rotation changes (throttled)
        let rotationTrackTimeout;
        rotationSlider.addEventListener('change', (e) => {
            clearTimeout(rotationTrackTimeout);
            rotationTrackTimeout = setTimeout(() => {
                if (typeof gtag !== 'undefined') {
                    gtag('event', 'rotation_adjusted', {
                        'event_category': 'Photo Editor',
                        'event_label': 'Rotation Control',
                        'value': Math.round(rotation)
                    });
                }
            }, 500);
        });

        function updateSliderValues() {
            const zoomPercent = Math.round(scale * 100);
            const rotationDegrees = rotation.toFixed(1);

            zoomValue.textContent = zoomPercent + '%';
            rotationValue.textContent = rotationDegrees + '¬∞';

            // Update ARIA attributes for accessibility
            zoomSlider.setAttribute('aria-valuenow', scale);
            zoomSlider.setAttribute('aria-valuetext', zoomPercent + '%');
            rotationSlider.setAttribute('aria-valuenow', rotation);
            rotationSlider.setAttribute('aria-valuetext', rotationDegrees + ' degrees');
        }

        // Mouse wheel zoom (smooth)
        canvasContainer.addEventListener('wheel', (e) => {
            // Prevent zoom while dragging or in crop mode
            if (isDragging || cropMode) {
                e.preventDefault();
                return;
            }

            e.preventDefault();

            // Increased sensitivity for better zoom out control
            let delta;
            if (e.deltaMode === 1) { // Line mode
                delta = e.deltaY * -0.05;
            } else { // Pixel mode (most common)
                delta = e.deltaY * -0.005; // Increased from 0.001 for better responsiveness
            }

            const newScale = Math.max(0.1, Math.min(3, scale + delta));

            // Only update if scale actually changed
            if (newScale !== scale) {
                scale = newScale;
                zoomSlider.value = scale;
                updateSliderValues();
                render();
            }
        }, { passive: false });

        // Pan with mouse
        canvasContainer.addEventListener('mousedown', (e) => {
            // Don't pan when in crop mode
            if (cropMode) return;

            e.preventDefault(); // Prevent any default browser behavior
            isDragging = true;
            dragStartX = e.clientX - offsetX;
            dragStartY = e.clientY - offsetY;
            canvasContainer.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            e.preventDefault(); // Prevent default during drag

            offsetX = e.clientX - dragStartX;
            offsetY = e.clientY - dragStartY;
            render();
        });

        document.addEventListener('mouseup', (e) => {
            if (isDragging) {
                e.preventDefault();
                isDragging = false;
                canvasContainer.style.cursor = 'move';
            }
        });

        // Touch support
        let lastTouchDistance = 0;

        canvasContainer.addEventListener('touchstart', (e) => {
            // Don't handle touch panning/zooming when in crop mode
            if (cropMode) return;

            if (e.touches.length === 1) {
                isDragging = true;
                dragStartX = e.touches[0].clientX - offsetX;
                dragStartY = e.touches[0].clientY - offsetY;
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
            }
        });

        canvasContainer.addEventListener('touchmove', (e) => {
            // Don't handle touch panning/zooming when in crop mode
            if (cropMode) return;

            e.preventDefault();

            if (e.touches.length === 1 && isDragging) {
                offsetX = e.touches[0].clientX - dragStartX;
                offsetY = e.touches[0].clientY - dragStartY;
                render();
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (lastTouchDistance > 0) {
                    const delta = (distance - lastTouchDistance) * 0.01;
                    scale = Math.max(0.1, Math.min(3, scale + delta));
                    zoomSlider.value = scale;
                    updateSliderValues();
                    render();
                }

                lastTouchDistance = distance;
            }
        });

        canvasContainer.addEventListener('touchend', () => {
            isDragging = false;
            lastTouchDistance = 0;
        });

        // Reset button
        resetBtn.addEventListener('click', () => {
            resetTransform();
            render();

            // Track reset action
            if (typeof gtag !== 'undefined') {
                gtag('event', 'reset_clicked', {
                    'event_category': 'Photo Editor',
                    'event_label': 'Reset Position'
                });
            }
        });

        // Initialize MediaPipe Selfie Segmentation for background removal
        let selfieSegmentation = null;
        let faceDetection = null;
        let selectedBackgroundColor = '#FFFFFF'; // Default white

        async function initializeSegmentation() {
            try {
                console.log('Starting MediaPipe initialization...');

                // Check if CDN fallback determined libraries are unavailable
                if (window.mediaPipeAvailable === false) {
                    console.warn('MediaPipe libraries unavailable (CDN blocked) - skipping initialization');
                    return;
                }

                // Check if MediaPipe libraries are loaded
                if (typeof SelfieSegmentation === 'undefined') {
                    console.warn('SelfieSegmentation not loaded');
                    window.mediaPipeAvailable = false;
                    return;
                }
                if (typeof FaceDetection === 'undefined') {
                    console.warn('FaceDetection not loaded');
                    window.mediaPipeAvailable = false;
                    return;
                }

                // Initialize Selfie Segmentation
                selfieSegmentation = new SelfieSegmentation({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`;
                    }
                });

                selfieSegmentation.setOptions({
                    modelSelection: 0, // 0 for general (0.5-2m), better for close-up passport photos
                });

                // Set up the onResults callback BEFORE using it
                selfieSegmentation.onResults(onSegmentationResults);
                console.log('SelfieSegmentation initialized');

                // Initialize Face Detection
                faceDetection = new FaceDetection({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}`;
                    }
                });

                faceDetection.setOptions({
                    model: 'short', // 'short' for faces within 2 meters
                    minDetectionConfidence: 0.5
                });

                // Set up face detection callback
                faceDetection.onResults(onFaceDetectionResults);
                console.log('FaceDetection initialized');

                console.log('MediaPipe libraries initialized successfully');
                window.mediaPipeAvailable = true;
            } catch (error) {
                console.error('Failed to initialize MediaPipe:', error);
                window.mediaPipeAvailable = false;
                // Face detection is still available even if initialization partially fails
            }
        }

        // Store the results for processing
        let currentSegmentationResults = null;
        let currentFaceResults = null;

        function onSegmentationResults(results) {
            currentSegmentationResults = results;
        }

        function onFaceDetectionResults(results) {
            currentFaceResults = results;
        }

        // Initialize on page load
        window.addEventListener('load', initializeSegmentation);

        // Toggle controls
        toggleFaceGuide.addEventListener('change', () => {
            render();

            // Update ARIA and track event
            toggleFaceGuide.setAttribute('aria-checked', toggleFaceGuide.checked);
            if (typeof gtag !== 'undefined') {
                gtag('event', 'toggle_face_guide', {
                    'event_category': 'Photo Editor',
                    'event_label': 'Face Outline Guide',
                    'value': toggleFaceGuide.checked ? 1 : 0
                });
            }
        });

        toggleGrid.addEventListener('change', () => {
            render();

            // Update ARIA and track event
            toggleGrid.setAttribute('aria-checked', toggleGrid.checked);
            if (typeof gtag !== 'undefined') {
                gtag('event', 'toggle_grid', {
                    'event_category': 'Photo Editor',
                    'event_label': 'Grid with Scale',
                    'value': toggleGrid.checked ? 1 : 0
                });
            }
        });

        // ========================================
        // CROP TOOL FUNCTIONALITY
        // ========================================

        // Toggle crop mode
        cropModeBtn.addEventListener('click', () => {
            cropMode = !cropMode;

            if (cropMode) {
                // Enable crop mode
                cropModeBtn.textContent = '‚úÇÔ∏è Disable Crop Mode';
                cropModeBtn.classList.remove('btn-primary');
                cropModeBtn.classList.add('btn-secondary');
                cropInstructions.style.display = 'block';
                cropControls.style.display = 'block';

                // Disable pan/zoom while cropping
                canvasContainer.style.cursor = 'crosshair';

                // Track crop mode enabled
                if (typeof gtag !== 'undefined') {
                    gtag('event', 'crop_mode_enabled', {
                        'event_category': 'Photo Editor',
                        'event_label': 'Crop Tool'
                    });
                }
            } else {
                // Disable crop mode
                exitCropMode();
            }
        });

        function exitCropMode() {
            cropMode = false;
            cropModeBtn.textContent = '‚úÇÔ∏è Enable Crop Mode';
            cropModeBtn.classList.remove('btn-secondary');
            cropModeBtn.classList.add('btn-primary');
            cropInstructions.style.display = 'none';
            cropControls.style.display = 'none';
            canvasContainer.style.cursor = 'move';

            // Remove crop rectangle if exists
            if (cropRect) {
                cropRect.remove();
                cropRect = null;
            }

            render();
        }

        // Handle crop rectangle drawing on canvas
        canvasContainer.addEventListener('mousedown', (e) => {
            if (!cropMode) return;

            const rect = canvasContainer.getBoundingClientRect();
            cropStartX = e.clientX - rect.left;
            cropStartY = e.clientY - rect.top;
            isCropping = true;

            // Remove existing crop rectangle
            if (cropRect) {
                cropRect.remove();
            }

            // Create new crop rectangle
            cropRect = document.createElement('div');
            cropRect.id = 'cropRect';
            cropRect.className = 'active';
            cropRect.style.left = cropStartX + 'px';
            cropRect.style.top = cropStartY + 'px';
            cropRect.style.width = '0px';
            cropRect.style.height = '0px';
            canvasContainer.appendChild(cropRect);
        });

        document.addEventListener('mousemove', (e) => {
            if (!isCropping || !cropMode) return;

            const rect = canvasContainer.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;

            const width = Math.abs(currentX - cropStartX);
            const height = Math.abs(currentY - cropStartY);
            const left = Math.min(cropStartX, currentX);
            const top = Math.min(cropStartY, currentY);

            if (cropRect) {
                cropRect.style.left = left + 'px';
                cropRect.style.top = top + 'px';
                cropRect.style.width = width + 'px';
                cropRect.style.height = height + 'px';
            }
        });

        document.addEventListener('mouseup', () => {
            if (isCropping) {
                isCropping = false;
            }
        });

        // Apply crop
        applyCropBtn.addEventListener('click', () => {
            if (!cropRect) {
                alert(t('cropNoCropArea', 'Please draw a crop area first'));
                return;
            }

            const rectStyle = cropRect.style;
            const cropX = parseFloat(rectStyle.left);
            const cropY = parseFloat(rectStyle.top);
            const cropWidth = parseFloat(rectStyle.width);
            const cropHeight = parseFloat(rectStyle.height);

            if (cropWidth < 10 || cropHeight < 10) {
                alert(t('cropAreaTooSmall', 'Crop area too small. Please draw a larger area.'));
                return;
            }

            // Create temporary canvas to perform crop
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = CANVAS_SIZE;
            tempCanvas.height = CANVAS_SIZE;
            const tempCtx = tempCanvas.getContext('2d');

            // Draw current canvas state to temp canvas
            tempCtx.drawImage(editCanvas, 0, 0);

            // Calculate crop coordinates relative to canvas
            const scaleX = CANVAS_SIZE / canvasContainer.clientWidth;
            const scaleY = CANVAS_SIZE / canvasContainer.clientHeight;

            const sourceCropX = cropX * scaleX;
            const sourceCropY = cropY * scaleY;
            const sourceCropWidth = cropWidth * scaleX;
            const sourceCropHeight = cropHeight * scaleY;

            // Create new image with cropped content
            const croppedCanvas = document.createElement('canvas');
            croppedCanvas.width = sourceCropWidth;
            croppedCanvas.height = sourceCropHeight;
            const croppedCtx = croppedCanvas.getContext('2d');

            croppedCtx.drawImage(
                tempCanvas,
                sourceCropX, sourceCropY, sourceCropWidth, sourceCropHeight,
                0, 0, sourceCropWidth, sourceCropHeight
            );

            // Convert to image and update current image
            const croppedImg = new Image();
            croppedImg.onload = () => {
                currentImage = croppedImg;
                resetTransform();
                render();
                exitCropMode();

                // Track crop applied
                if (typeof gtag !== 'undefined') {
                    gtag('event', 'crop_applied', {
                        'event_category': 'Photo Editor',
                        'event_label': 'Crop Tool'
                    });
                }

                alert(t('cropAppliedSuccess', 'Crop applied successfully!'));
            };
            croppedImg.src = croppedCanvas.toDataURL();
        });

        // Cancel crop
        cancelCropBtn.addEventListener('click', () => {
            exitCropMode();
        });

        // ========================================
        // KEYBOARD SHORTCUTS
        // ========================================

        document.addEventListener('keydown', (e) => {
            // Ignore if typing in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            // Don't handle shortcuts if no image is loaded
            if (!currentImage) {
                return;
            }

            switch(e.key.toLowerCase()) {
                case '+':
                case '=':
                    // Zoom in
                    e.preventDefault();
                    scale = Math.min(3, scale + 0.1);
                    zoomSlider.value = scale;
                    updateSliderValues();
                    render();
                    break;

                case '-':
                case '_':
                    // Zoom out
                    e.preventDefault();
                    scale = Math.max(0.1, scale - 0.1);
                    zoomSlider.value = scale;
                    updateSliderValues();
                    render();
                    break;

                case 'arrowleft':
                    // Rotate left
                    e.preventDefault();
                    rotation = Math.max(-45, rotation - 1);
                    rotationSlider.value = rotation;
                    updateSliderValues();
                    render();
                    break;

                case 'arrowright':
                    // Rotate right
                    e.preventDefault();
                    rotation = Math.min(45, rotation + 1);
                    rotationSlider.value = rotation;
                    updateSliderValues();
                    render();
                    break;

                case 'r':
                    // Reset position
                    e.preventDefault();
                    if (resetBtn && !resetBtn.disabled) {
                        resetTransform();
                        render();
                    }
                    break;

                case 'c':
                    // Toggle crop mode
                    e.preventDefault();
                    if (cropModeBtn && !cropModeBtn.disabled) {
                        cropModeBtn.click();
                    }
                    break;

                case 'v':
                    // Validate face
                    e.preventDefault();
                    if (validateFaceBtn && !validateFaceBtn.disabled) {
                        validateFaceBtn.click();
                    }
                    break;

                case 'escape':
                    // Cancel crop mode
                    e.preventDefault();
                    if (cropMode) {
                        exitCropMode();
                    }
                    break;
            }

            // Track keyboard shortcut usage
            if (typeof gtag !== 'undefined' && ['+',' ', '-', 'arrowleft', 'arrowright', 'r', 'c', 'v', 'escape'].includes(e.key.toLowerCase())) {
                gtag('event', 'keyboard_shortcut_used', {
                    'event_category': 'Photo Editor',
                    'event_label': e.key
                });
            }
        });

        // Face validation using MediaPipe Face Detection
        validateFaceBtn.addEventListener('click', async () => {
            console.log('Face validation button clicked');
            console.log('Current image:', currentImage);
            console.log('MediaPipe available:', window.mediaPipeAvailable);
            console.log('Face detection initialized:', faceDetection);

            // Track face validation click
            if (typeof gtag !== 'undefined') {
                gtag('event', 'face_validation_started', {
                    'event_category': 'Photo Editor',
                    'event_label': 'Face Validation'
                });
            }

            if (!currentImage) {
                console.error('No image loaded');
                return;
            }

            // Check if MediaPipe libraries are available
            if (window.mediaPipeAvailable === false) {
                console.error('MediaPipe libraries not available (CDN blocked)');
                validationResults.style.display = 'block';
                validationResults.style.background = '#F8D7DA';
                validationResults.style.borderLeft = '4px solid #DC3545';
                validationResults.innerHTML = `
                    <strong style="color: #721C24;">${t('faceValidationUnavailableTitle', '‚ùå Face Validation Unavailable')}</strong>
                    <p style="color: #721C24; margin-top: 8px;">${t('faceValidationUnavailableDesc', 'Face detection libraries couldn\'t be loaded from CDN sources.')}</p>
                    <p style="color: #721C24; margin-top: 8px; font-size: 13px;">
                        ${t('faceValidationUnavailableHint', 'This may be due to network restrictions or ad blockers. All other editing features work normally. You can still adjust your photo using the zoom, rotation, and crop tools.')}
                    </p>
                `;
                return;
            }

            if (!faceDetection) {
                console.error('Face detection not initialized');
                validationResults.style.display = 'block';
                validationResults.style.background = '#FFF3CD';
                validationResults.style.borderLeft = '4px solid #FFA500';
                validationResults.innerHTML = `
                    <strong style="color: #856404;">${t('faceDetectionNotReadyTitle', '‚ö†Ô∏è Face Detection Not Ready')}</strong>
                    <p style="color: #856404; margin-top: 8px;">${t('faceDetectionNotReadyDesc', 'Face detection is still loading. Please wait a moment and try again.')}</p>
                    <p style="color: #856404; margin-top: 8px; font-size: 12px;">${t('faceDetectionNotReadyHint', 'If this persists, try refreshing the page.')}</p>
                `;
                return;
            }

            validationResults.style.display = 'block';
            validationResults.innerHTML = `<div class="spinner" style="width: 20px; height: 20px; margin: 0 auto;"></div><p style="text-align: center; margin-top: 10px;">${t('faceValidationAnalyzing', 'Analyzing face position...')}</p>`;
            validateFaceBtn.disabled = true;

            try {
                // Create temporary canvas for processing
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = currentImage.width;
                tempCanvas.height = currentImage.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(currentImage, 0, 0);

                // Reset results
                currentFaceResults = null;

                // Process with MediaPipe
                await faceDetection.send({image: tempCanvas});

                // Wait for results (with timeout)
                const maxWait = 5000; // 5 seconds
                const startTime = Date.now();

                while (!currentFaceResults && (Date.now() - startTime) < maxWait) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                if (!currentFaceResults || !currentFaceResults.detections || currentFaceResults.detections.length === 0) {
                    validationResults.style.background = '#FFF3CD';
                    validationResults.style.borderLeft = '4px solid #FFA500';
                    validationResults.innerHTML = `
                        <strong style="color: #856404;">${t('noFaceDetectedTitle', '‚ö†Ô∏è No Face Detected')}</strong>
                        <p style="color: #856404; margin-top: 8px;">${t('noFaceDetectedDesc', 'Make sure:')}</p>
                        <ul style="color: #856404; margin-left: 20px; margin-top: 8px;">
                            <li>${t('noFaceDetectedTip1', 'Your face is clearly visible')}</li>
                            <li>${t('noFaceDetectedTip2', 'Good lighting conditions')}</li>
                            <li>${t('noFaceDetectedTip3', 'Face is centered in the photo')}</li>
                            <li>${t('noFaceDetectedTip4', 'Zoom in to make face larger')}</li>
                        </ul>
                    `;
                    validateFaceBtn.disabled = false;
                    return;
                }

                // ========================================
                // COMPREHENSIVE FACE VALIDATION SYSTEM
                // ========================================

                const face = currentFaceResults.detections[0];
                const bbox = face.boundingBox;
                const landmarks = face.landmarks;

                // Debug info object
                const debugInfo = {
                    method: 'unknown',
                    hasEyes: false,
                    hasNose: false,
                    hasMouth: false,
                    bboxCoverage: 'unknown'
                };

                // ========================================
                // STEP 1: Extract all available landmarks
                // ========================================
                let rightEye = null, leftEye = null, noseTip = null, mouthCenter = null;

                if (landmarks && landmarks.length >= 2) {
                    rightEye = landmarks[0];  // Right eye
                    leftEye = landmarks[1];   // Left eye
                    debugInfo.hasEyes = true;

                    if (landmarks.length >= 3) {
                        noseTip = landmarks[2];
                        debugInfo.hasNose = true;
                    }
                    if (landmarks.length >= 4) {
                        mouthCenter = landmarks[3];
                        debugInfo.hasMouth = true;
                    }
                }

                // ========================================
                // STEP 2: Convert bbox to pixel coordinates
                // ========================================
                const bboxLeft = (bbox.xCenter - bbox.width / 2) * currentImage.width;
                const bboxTop = (bbox.yCenter - bbox.height / 2) * currentImage.height;
                const bboxRight = (bbox.xCenter + bbox.width / 2) * currentImage.width;
                const bboxBottom = (bbox.yCenter + bbox.height / 2) * currentImage.height;
                const bboxWidthPx = bboxRight - bboxLeft;
                const bboxHeightPx = bboxBottom - bboxTop;
                const bboxCenterX = (bboxLeft + bboxRight) / 2;
                const bboxCenterY = (bboxTop + bboxBottom) / 2;

                // ========================================
                // STEP 3: Determine head boundaries using multi-strategy approach
                // ========================================
                let crownYPx, chinYPx, headCenterXPx, headCenterYPx;
                let eyeYPx = null, noseYPx = null, mouthYPx = null;

                if (rightEye && leftEye) {
                    // Strategy: Eye-landmark based (most accurate)
                    debugInfo.method = 'eye-landmark';

                    const eyeCenterX = (rightEye.x + leftEye.x) / 2;
                    const eyeCenterY = (rightEye.y + leftEye.y) / 2;
                    eyeYPx = eyeCenterY * currentImage.height;
                    headCenterXPx = eyeCenterX * currentImage.width;

                    // Get additional landmarks for better accuracy
                    if (noseTip) {
                        noseYPx = noseTip.y * currentImage.height;
                    }
                    if (mouthCenter) {
                        mouthYPx = mouthCenter.y * currentImage.height;
                    }

                    // ANATOMICAL PROPORTIONS (adult human head):
                    // - Crown to eyes: ~43% of total head height
                    // - Eyes to nose: ~17% of total head height
                    // - Nose to mouth: ~10% of total head height
                    // - Mouth to chin: ~30% of total head height

                    // Method A: If we have mouth, use eye-to-mouth distance
                    if (mouthYPx) {
                        const eyeToMouthPx = mouthYPx - eyeYPx;
                        // Eye to mouth is ~27% of head, so full head = eyeToMouth / 0.27
                        const estimatedHeadHeight = eyeToMouthPx / 0.27;

                        // Crown is 43% of head above eyes
                        crownYPx = eyeYPx - (estimatedHeadHeight * 0.43);
                        // Chin is 57% of head below eyes (100% - 43%)
                        chinYPx = eyeYPx + (estimatedHeadHeight * 0.57);

                        debugInfo.bboxCoverage = 'eye-mouth-based';
                    }
                    // Method B: If we have nose but no mouth
                    else if (noseYPx) {
                        const eyeToNosePx = noseYPx - eyeYPx;
                        // Eye to nose is ~17% of head, so full head = eyeToNose / 0.17
                        const estimatedHeadHeight = eyeToNosePx / 0.17;

                        crownYPx = eyeYPx - (estimatedHeadHeight * 0.43);
                        chinYPx = eyeYPx + (estimatedHeadHeight * 0.57);

                        debugInfo.bboxCoverage = 'eye-nose-based';
                    }
                    // Method C: Use bbox bottom as chin approximation
                    else {
                        // Bbox bottom is usually close to chin
                        chinYPx = bboxBottom;
                        const eyeToChinPx = chinYPx - eyeYPx;
                        // Eye to chin is ~57% of head, so full head = eyeToChin / 0.57
                        const estimatedHeadHeight = eyeToChinPx / 0.57;

                        crownYPx = eyeYPx - (estimatedHeadHeight * 0.43);

                        debugInfo.bboxCoverage = 'eye-bbox-based';
                    }

                    // Head center Y is midpoint between crown and chin
                    headCenterYPx = (crownYPx + chinYPx) / 2;

                } else {
                    // Strategy: Bbox-only based (fallback)
                    debugInfo.method = 'bbox-only';

                    headCenterXPx = bboxCenterX;

                    // Assumption: MediaPipe bbox typically captures from hairline/forehead to chin
                    // This is roughly 85-90% of full head (crown to chin)
                    // We need to add ~10-15% above the bbox top for full crown

                    const extraAbove = bboxHeightPx * 0.12; // Add 12% above for crown
                    crownYPx = bboxTop - extraAbove;
                    chinYPx = bboxBottom;
                    headCenterYPx = (crownYPx + chinYPx) / 2;

                    debugInfo.bboxCoverage = 'bbox-only-with-crown-estimate';
                }

                const headHeightPx = chinYPx - crownYPx;

                // ========================================
                // STEP 4: Transform source coordinates to canvas coordinates
                // ========================================
                // The canvas transformation is:
                // 1. Image is centered at canvas center
                // 2. Rotation is applied around canvas center
                // 3. Scale is applied
                // 4. Offset (pan) is applied

                const canvasCenterX = CANVAS_SIZE / 2;
                const canvasCenterY = CANVAS_SIZE / 2;

                // Helper function to transform a point from source to canvas
                function transformToCanvas(sourceX, sourceY) {
                    // Position relative to source image center
                    const relX = sourceX - currentImage.width / 2;
                    const relY = sourceY - currentImage.height / 2;

                    // Apply rotation around origin (0,0)
                    const rotRad = (rotation * Math.PI) / 180;
                    const cosRot = Math.cos(rotRad);
                    const sinRot = Math.sin(rotRad);
                    const rotX = relX * cosRot - relY * sinRot;
                    const rotY = relX * sinRot + relY * cosRot;

                    // Apply scale
                    const scaledX = rotX * scale;
                    const scaledY = rotY * scale;

                    // Apply offset and translate to canvas center
                    const canvasX = canvasCenterX + scaledX + offsetX;
                    const canvasY = canvasCenterY + scaledY + offsetY;

                    return { x: canvasX, y: canvasY };
                }

                // Transform head points to canvas
                const canvasHeadCenter = transformToCanvas(headCenterXPx, headCenterYPx);
                const canvasCrown = transformToCanvas(headCenterXPx, crownYPx);
                const canvasChin = transformToCanvas(headCenterXPx, chinYPx);

                // Head height on canvas (accounting for rotation)
                const canvasHeadHeight = Math.abs(canvasChin.y - canvasCrown.y);

                // Use transformed coordinates
                const canvasHeadCenterX = canvasHeadCenter.x;
                const canvasHeadCenterY = canvasHeadCenter.y;
                const canvasCrownY = canvasCrown.y;
                const canvasChinY = canvasChin.y;

                // ========================================
                // STEP 5: Calculate percentages and validate
                // ========================================

                // Calculate head height as percentage of canvas
                const headHeightPercent = (canvasHeadHeight / CANVAS_SIZE) * 100;

                // Face center position as percentage from top/left
                const faceCenterYPercent = (canvasHeadCenterY / CANVAS_SIZE) * 100;
                const faceCenterXPercent = (canvasHeadCenterX / CANVAS_SIZE) * 100;

                // Crown and chin positions as percentage (for detailed feedback)
                const crownYPercent = (canvasCrownY / CANVAS_SIZE) * 100;
                const chinYPercent = (canvasChinY / CANVAS_SIZE) * 100;

                // ========================================
                // STEP 6: Define target values (matching our oval guideline)
                // ========================================

                const targetHeadHeight = 60;        // Our oval is 60% tall
                const targetVerticalCenter = 47.5;  // Our oval center at 47.5%
                const targetHorizontalCenter = 50;  // Centered at 50%
                const targetCrownY = 17.5;          // Our oval crown at 17.5%
                const targetChinY = 77.5;           // Our oval chin at 77.5%

                // ========================================
                // STEP 7: Perform validation with progressive tolerance
                // ========================================

                const results = [];
                let allGood = true;

                // SIZE VALIDATION
                const heightDiff = Math.abs(headHeightPercent - targetHeadHeight);
                if (headHeightPercent < 40) {
                    results.push({ status: 'error', text: '‚ùå Face too small - zoom in significantly' });
                    allGood = false;
                } else if (headHeightPercent > 80) {
                    results.push({ status: 'error', text: '‚ùå Face too large - zoom out significantly' });
                    allGood = false;
                } else if (heightDiff > 15) {
                    if (headHeightPercent < targetHeadHeight) {
                        results.push({ status: 'warning', text: `‚ö†Ô∏è Face small (${headHeightPercent.toFixed(0)}%) - zoom in more` });
                    } else {
                        results.push({ status: 'warning', text: `‚ö†Ô∏è Face large (${headHeightPercent.toFixed(0)}%) - zoom out more` });
                    }
                } else if (heightDiff > 8) {
                    if (headHeightPercent < targetHeadHeight) {
                        results.push({ status: 'success', text: `‚úì Face size acceptable - could zoom in slightly to ${targetHeadHeight}%` });
                    } else {
                        results.push({ status: 'success', text: `‚úì Face size acceptable - could zoom out slightly to ${targetHeadHeight}%` });
                    }
                } else if (heightDiff > 3) {
                    results.push({ status: 'success', text: `‚úì Face size good (${headHeightPercent.toFixed(1)}% vs ${targetHeadHeight}%)` });
                } else {
                    results.push({ status: 'success', text: `‚úì Face size perfect! (${headHeightPercent.toFixed(1)}%)` });
                }

                // VERTICAL POSITION VALIDATION
                const verticalDiff = Math.abs(faceCenterYPercent - targetVerticalCenter);
                const crownDiff = Math.abs(crownYPercent - targetCrownY);
                const chinDiff = Math.abs(chinYPercent - targetChinY);

                if (faceCenterYPercent < 25 || crownYPercent < 0) {
                    results.push({ status: 'error', text: '‚ùå Face too high - pan down significantly' });
                    allGood = false;
                } else if (faceCenterYPercent > 70 || chinYPercent > 100) {
                    results.push({ status: 'error', text: '‚ùå Face too low - pan up significantly' });
                    allGood = false;
                } else if (verticalDiff > 12) {
                    if (faceCenterYPercent < targetVerticalCenter) {
                        results.push({ status: 'warning', text: `‚ö†Ô∏è Face high (${faceCenterYPercent.toFixed(0)}%) - pan down to ~${targetVerticalCenter}%` });
                    } else {
                        results.push({ status: 'warning', text: `‚ö†Ô∏è Face low (${faceCenterYPercent.toFixed(0)}%) - pan up to ~${targetVerticalCenter}%` });
                    }
                } else if (verticalDiff > 6) {
                    if (faceCenterYPercent < targetVerticalCenter) {
                        results.push({ status: 'success', text: `‚úì Vertical acceptable - pan down slightly for perfect alignment` });
                    } else {
                        results.push({ status: 'success', text: `‚úì Vertical acceptable - pan up slightly for perfect alignment` });
                    }
                } else if (verticalDiff > 2) {
                    results.push({ status: 'success', text: `‚úì Vertical position good (${faceCenterYPercent.toFixed(1)}%)` });
                } else {
                    results.push({ status: 'success', text: `‚úì Vertical position perfect! (${faceCenterYPercent.toFixed(1)}%)` });
                }

                // HORIZONTAL POSITION VALIDATION
                const horizontalDiff = Math.abs(faceCenterXPercent - targetHorizontalCenter);
                if (faceCenterXPercent < 25) {
                    results.push({ status: 'error', text: '‚ùå Face too far left - pan right significantly' });
                    allGood = false;
                } else if (faceCenterXPercent > 75) {
                    results.push({ status: 'error', text: '‚ùå Face too far right - pan left significantly' });
                    allGood = false;
                } else if (horizontalDiff > 12) {
                    if (faceCenterXPercent < targetHorizontalCenter) {
                        results.push({ status: 'warning', text: `‚ö†Ô∏è Face left (${faceCenterXPercent.toFixed(0)}%) - pan right` });
                    } else {
                        results.push({ status: 'warning', text: `‚ö†Ô∏è Face right (${faceCenterXPercent.toFixed(0)}%) - pan left` });
                    }
                } else if (horizontalDiff > 5) {
                    results.push({ status: 'success', text: `‚úì Horizontal acceptable - minor adjustment possible` });
                } else if (horizontalDiff > 2) {
                    results.push({ status: 'success', text: `‚úì Horizontally centered (${faceCenterXPercent.toFixed(1)}%)` });
                } else {
                    results.push({ status: 'success', text: `‚úì Perfectly centered horizontally! (${faceCenterXPercent.toFixed(1)}%)` });
                }

                // ========================================
                // STEP 8: Display results with detailed feedback
                // ========================================
                const bgColor = allGood ? '#D4EDDA' : '#FFF3CD';
                const borderColor = allGood ? '#28A745' : '#FFA500';
                validationResults.style.background = bgColor;
                validationResults.style.borderLeft = `4px solid ${borderColor}`;

                // Track validation results
                if (typeof gtag !== 'undefined') {
                    gtag('event', 'face_validation_completed', {
                        'event_category': 'Photo Editor',
                        'event_label': allGood ? 'Perfect Alignment' : 'Needs Adjustment',
                        'value': allGood ? 1 : 0
                    });
                }

                let html = allGood
                    ? `<strong style="color: #155724;">${t('validationPerfect', 'üéâ Perfect! Your photo aligns with the guideline')}</strong>`
                    : `<strong style="color: #856404;">${t('validationAnalysis', 'üìä Face Position Analysis')}</strong>`;

                html += '<ul style="margin: 12px 0 0 20px; padding: 0;">';
                results.forEach(result => {
                    const color = result.status === 'success' ? '#155724' :
                                 result.status === 'warning' ? '#856404' : '#721C24';
                    html += `<li style="color: ${color}; margin: 6px 0;">${result.text}</li>`;
                });
                html += '</ul>';

                // Add toggle button for detailed stats
                html += `
                    <div style="text-align: center; margin-top: 12px;">
                        <button id="toggleStatsBtn" style="padding: 8px 16px; border: 1px solid #007AFF; background: white; color: #007AFF; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.2s;">
                            ${t('showDetailedStats', 'ü§ì Show Detailed Stats')}
                        </button>
                    </div>
                `;

                // Build detection method description
                let methodDesc = '';
                if (debugInfo.method === 'eye-landmark') {
                    if (debugInfo.bboxCoverage === 'eye-mouth-based') {
                        methodDesc = 'üëÅÔ∏èüëÑ Eye+Mouth Landmarks (Highest Accuracy)';
                    } else if (debugInfo.bboxCoverage === 'eye-nose-based') {
                        methodDesc = 'üëÅÔ∏èüëÉ Eye+Nose Landmarks (High Accuracy)';
                    } else {
                        methodDesc = 'üëÅÔ∏è Eye Landmarks (Good Accuracy)';
                    }
                } else {
                    methodDesc = 'üì¶ Bounding Box Only (Standard)';
                }

                // Detailed measurements section (hidden by default)
                html += `
                    <div id="detailedStats" style="display: none; margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(0,0,0,0.1); font-size: 12px; color: #666;">
                        <div style="background: rgba(0, 122, 255, 0.05); padding: 8px; border-radius: 6px; margin-bottom: 10px;">
                            <strong style="color: #007AFF;">üîç Detection:</strong> ${methodDesc}
                        </div>

                        <strong>üìè Current Measurements:</strong><br>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin: 6px 0;">
                            <span>‚Ä¢ Head height:</span> <span style="font-weight: 600;">${headHeightPercent.toFixed(1)}%</span>
                            <span>‚Ä¢ Center vertical:</span> <span style="font-weight: 600;">${faceCenterYPercent.toFixed(1)}%</span>
                            <span>‚Ä¢ Center horizontal:</span> <span style="font-weight: 600;">${faceCenterXPercent.toFixed(1)}%</span>
                        </div>

                        <strong style="margin-top: 8px; display: block;">üéØ Target Guideline:</strong><br>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin: 6px 0;">
                            <span>‚Ä¢ Head height:</span> <span style="color: #007AFF; font-weight: 600;">${targetHeadHeight}%</span>
                            <span>‚Ä¢ Center vertical:</span> <span style="color: #007AFF; font-weight: 600;">${targetVerticalCenter}%</span>
                            <span>‚Ä¢ Center horizontal:</span> <span style="color: #007AFF; font-weight: 600;">${targetHorizontalCenter}%</span>
                        </div>

                        <strong style="margin-top: 8px; display: block;">üìç Detailed Positions:</strong><br>
                        <div style="display: grid; grid-template-columns: auto 1fr 1fr; gap: 4px 8px; margin: 6px 0; font-size: 11px;">
                            <span></span><span style="text-align: center; font-weight: 600;">Current</span><span style="text-align: center; font-weight: 600; color: #007AFF;">Target</span>
                            <span>Crown:</span><span style="text-align: center;">${crownYPercent.toFixed(1)}%</span><span style="text-align: center; color: #007AFF;">${targetCrownY}%</span>
                            <span>Chin:</span><span style="text-align: center;">${chinYPercent.toFixed(1)}%</span><span style="text-align: center; color: #007AFF;">${targetChinY}%</span>
                        </div>

                        <div style="margin-top: 10px; padding: 8px; background: rgba(52, 199, 89, 0.05); border-radius: 6px; font-size: 11px; line-height: 1.5;">
                            <strong style="color: #28A745;">üí° Tips:</strong><br>
                            ‚Ä¢ Align crown & chin with blue oval markers<br>
                            ‚Ä¢ Use mouse wheel or slider to zoom<br>
                            ‚Ä¢ Click and drag to pan the image
                        </div>
                    </div>
                `;

                validationResults.innerHTML = html;

                // Add event listener for toggle button
                const toggleBtn = document.getElementById('toggleStatsBtn');
                if (toggleBtn) {
                    toggleBtn.addEventListener('click', () => {
                        const detailedStats = document.getElementById('detailedStats');
                        if (detailedStats) {
                            const isHidden = detailedStats.style.display === 'none';
                            detailedStats.style.display = isHidden ? 'block' : 'none';
                            toggleBtn.textContent = isHidden ? t('hideDetailedStats', 'üìä Hide Detailed Stats') : t('showDetailedStats', 'ü§ì Show Detailed Stats');
                            toggleBtn.style.background = isHidden ? '#007AFF' : 'white';
                            toggleBtn.style.color = isHidden ? 'white' : '#007AFF';
                        }
                    });
                }

            } catch (error) {
                console.error('Face validation failed:', error);
                validationResults.style.background = '#F8D7DA';
                validationResults.style.borderLeft = '4px solid #DC3545';
                validationResults.innerHTML = `
                    <strong style="color: #721C24;">${t('validationFailedTitle', '‚ùå Validation Failed')}</strong>
                    <p style="color: #721C24; margin-top: 8px;">${error.message}</p>
                    <p style="color: #721C24; margin-top: 8px;">${t('validationFailedDesc', 'Please try again or use a different photo.')}</p>
                `;
            } finally {
                validateFaceBtn.disabled = false;
            }
        });

        // ======================================
        // Export and Download buttons - Now handled by photoHandler module
        // See integration script at bottom of file
        // ======================================


        // ========================================
        // LOCALIZATION SYSTEM
        // ========================================

        // Translations are now loaded from translations/index.js module
        // The module automatically assigns to window.translations
        // Keeping this as a fallback for file:// protocol compatibility
        const translations = window.translations || {};

        // Helper function to get translation with fallback
        function t(key, fallback = '') {
            const lang = getLanguage();
            return translations[lang]?.[key] || translations.en?.[key] || fallback;
        }

        // Get or set language preference
        function getLanguage() {
            return localStorage.getItem('preferredLanguage') || 'en';
        }

        function setLanguage(lang) {
            localStorage.setItem('preferredLanguage', lang);
        }

        // Apply translations to the page
        function applyTranslations(lang) {
            // Ensure translations object exists
            if (!translations || typeof translations !== 'object') {
                console.warn('Translations not loaded yet, waiting...');
                return;
            }

            const trans = translations[lang] || translations.en;

            // Safety check - ensure trans has data
            if (!trans || typeof trans !== 'object') {
                console.warn(`Translation for language "${lang}" not found, using English fallback`);
                return;
            }

            // Update all elements with data-i18n attribute
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (trans[key]) {
                    element.textContent = trans[key];
                }
            });

            // Update document title
            if (trans.page_title) {
                document.title = trans.page_title + " - Passport Photo Maker";
            }

            // Track language change
            if (typeof gtag !== 'undefined') {
                gtag('event', 'language_changed', {
                    'event_category': 'Localization',
                    'event_label': lang
                });
            }
        }

        // Language selector event listener
        const languageSelect = document.getElementById('languageSelect');
        if (languageSelect) {
            // Set initial language
            const currentLang = getLanguage();
            languageSelect.value = currentLang;
            applyTranslations(currentLang);

            // Handle language change
            languageSelect.addEventListener('change', (e) => {
                const newLang = e.target.value;
                setLanguage(newLang);
                applyTranslations(newLang);

                // Optional: Show confirmation
                console.log(`Language changed to: ${newLang}`);
            });
        }

        // Apply translations on page load
        document.addEventListener('DOMContentLoaded', () => {
            const lang = getLanguage();
            if (languageSelect) {
                languageSelect.value = lang;
            }
            applyTranslations(lang);
        });
    </script>

    <!-- UX Components Initialization -->
    <script type="module">
        import { initMobileNav, initStickyNav } from './js/ux-components.js';

        // Import common utilities
        import { initCommon } from './js/common.js';

        // Initialize basic UX components
        document.addEventListener('DOMContentLoaded', async () => {
            // Load footer first
            await initCommon();

            initMobileNav();
            initStickyNav();
        });
    </script>

    <!-- ================================================== -->
    <!-- Photo Handler Module Integration -->
    <!-- ================================================== -->
    <script type="module">
        import { PhotoStorage } from './js/photoHandler.js';
        import {
            initPhotoEditorUpload,
            handleUsePhoto,
            handleDownloadPhoto
        } from './js/photoHandler-editor.js';

        // Photo handler and storage instances
        let photoHandler = null;
        const photoStorage = new PhotoStorage();

        // Initialize function
        function initializePhotoHandler() {
            // Get current language for translations
            const currentLang = getLanguage();
            const trans = translations[currentLang] || translations.en;

            // Initialize photo upload with image loading callback
            photoHandler = initPhotoEditorUpload(
                trans,
                (image, dataURL, metadata) => {
                    console.log('Photo loaded via photoHandler:', metadata);

                    // Set images for editor
                    originalImage = image;
                    currentImage = image;

                    // Initialize editor with the image
                    resetTransform();
                    render();
                    enableControls();

                    // Show canvas area
                    const uploadPrompt = document.getElementById('uploadPrompt');
                    const canvasContainer = document.getElementById('canvasContainer');
                    const photoInfo = document.getElementById('photoInfo');

                    if (uploadPrompt) uploadPrompt.style.display = 'none';
                    if (canvasContainer) canvasContainer.style.display = 'block';
                    if (photoInfo) photoInfo.style.display = 'block';
                }
            );

            console.log('Photo handler initialized for photo editor');
        }

        // Call immediately if DOM already loaded, otherwise wait for DOMContentLoaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializePhotoHandler);
        } else {
            // DOM is already loaded, initialize immediately
            initializePhotoHandler();
        }

        // Connect the "Use Photo" button (Create Photo Sheet)
        const exportBtn = document.getElementById('exportBtn');
        if (exportBtn) {
            exportBtn.addEventListener('click', () => {
                console.log('Use Photo clicked');

                const editCanvas = document.getElementById('editCanvas');
                if (editCanvas) {
                    handleUsePhoto(editCanvas, photoStorage);
                } else {
                    console.error('Edit canvas not found');
                }
            });
        }

        // Connect the "Download" button
        const downloadBtn = document.getElementById('downloadBtn');
        if (downloadBtn) {
            downloadBtn.addEventListener('click', () => {
                console.log('Download clicked');

                const editCanvas = document.getElementById('editCanvas');
                if (editCanvas) {
                    handleDownloadPhoto(editCanvas, 'passport-photo-edited.jpg');
                } else {
                    console.error('Edit canvas not found');
                }
            });
        }

        // Update upload text when language changes
        // Hook into existing applyTranslations function
        const originalApplyTranslations = window.applyTranslations;
        if (typeof originalApplyTranslations === 'function') {
            window.applyTranslations = function(lang) {
                // Call original translation function
                originalApplyTranslations(lang);

                // Update photo handler text
                if (photoHandler && translations[lang]) {
                    const trans = translations[lang];
                    photoHandler.updateText({
                        uploadText: trans.upload_text || 'Choose Your Photo',
                        uploadHint: trans.upload_hint || 'Click or drag and drop',
                        successMessage: trans.uploadSuccess || 'Photo uploaded successfully'
                    });
                }
            };
        }

        // Make instances accessible globally for debugging
        window.photoHandler = photoHandler;
        window.photoStorage = photoStorage;
    </script>
</body>
</html>
